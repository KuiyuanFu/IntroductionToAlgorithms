# IntroductionToAlgorithms

## 第一部分 基础知识



## 第1章 算法在计算中的作用

### 算法

对于给定的输入，有限时间内给出正确的输出。

- **输入**

- **输出**

- **有穷性**

- **确切性**

- **可行性**



## 第2章 算法基础



### 排序

输出为输入序列的一个特定顺序的排列。

排列的元素成为关键字，输入就是关键字的数组。



### 循环不变式

在排序过程中，每一步都保持顺序的一段序列。

- **初始化**：循环的第一次迭代之前，就是真的。
- **保持**：如果在每次循环前是真的，那么下次循环前仍是真的。
- **终止**：循环终止时，仍是真的。



### 插入排序

第 `n` 次循环时，前 `n-1` 个元素组成的序列为**循环不变式**，此次将第 `n` 个按顺序**插入**到前 `n-1` 个中。

````c++
InsertionSort(A)
    for j = 2 to A.length
    	key = A[j]
        // 插入，通过移位的方式执行。
        i=j-1
        while i >0 and A[i]>key
            A[i+1]=A[i]
            i = i-1
        A[i+1] =key
````



### 分治法

 分治法通常可以使用递归结构，三个步骤：

- **分解**：将原问题分解为若干子问题，这些子问题是原问题的规模较小的实例。
- **解决**：对子问题递归求解，子问题较小时，直接求解。
- **合并**：将子问题的解组合成原问题的解。



### 归并排序

分两段，合并，两倍空间。

````c++
Merge(A,p,q,r)
    n1 = q-p+1
    n2 = r-q
    let L[1..n1+1] and R[1..n_2+1] be new arrays
    for i=1 to n1
        L[i]=A[p+i-1]
    for j=1 to n2
        R[j]=A[p+j-1]
    L[n1+1] = +infin
    R[n2+1] = +infin
    i =1 
    j =1
    for k=p to r
        if L[i] <= R[j]
            A[k]= L[i]
            i+=1
        else
            A[k]= R[j]
            j+=1
            
MergeSort(A,p,r)
    if p <r
        q = (p+r)/2
        MergeSort(A,p,q)
        MergeSort(A,q+1,r)
        Merge(A,p,q,r)
            
````







## 第3章 函数的增长

### 渐进效率

当输入规模足够大，使得只与运行时间的增长量级有关，即算法的渐进效率，忽略较小的增长量级与常数项。

- $\Theta(g(x)) = \{f(x)|\exist c_1,c_2,n_0 ,\forall n\geq n_0,0\leq c_1g(n)\leq f(n) \leq c_2g(n)\}$  ，渐进紧确界，就是说 $f(x)$ 被 $g(x)$ 夹在了中间。
- $O(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0\leq  f(n) \leq cg(n)\}$  ，渐进上界，就是说 $f(x)$ 在 $g(x)$ 下面。 $g(x)$ 可能同阶，也可能高阶。
- $\Omega(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0 \leq cg(n)\leq  f(n)\}$  ，渐进下界，就是说 $f(x)$ 在 $g(x)$ 上面。 $g(x)$ 可能同阶，也可能低阶。
- $o(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0\leq  f(n) < cg(n)\}$  ，非渐进紧确的上界，就是说 $f(x)$ 在 $g(x)$ 下面。 $g(x)$ 高阶。
- $\omega(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0 \leq cg(n)<  f(n)\}$  ，非渐进紧确的下界，就是说 $f(x)$ 在 $g(x)$ 上面。 $g(x)$ 低阶。



## 第4章 分治策略

 ### 分治法

分治法通常可以使用递归结构，三个步骤：

- **分解**：将原问题分解为若干子问题，这些子问题是原问题的规模较小的实例。
- **解决**：对子问题递归求解，子问题较小时，直接求解。
- **合并**：将子问题的解组合成原问题的解。

在解决问题这步骤中，如果子问题足够大，需要递归求解时，称之为**递归情况**；而子问题足够小，可以直接求解，叫做**基本情况**。



关键点是如何分解成**更小规模**的相同问题。



###  递归式

**递归式通过**更小的输入上的**函数值**来描述一个**函数**。
$$
T(n)=\cases{ \Theta(1) & n=1 \\a T(n/b) + \Theta(n) & n>1 }
$$


### 求解递归式的方法

- **代入法**：猜测一个界，之后用数学归纳法证明其正确性。
- **递归树法**：将递归式转化为一棵树，其结点表示不同层次的递归调用产生的代价。然后采用边界和技术求解递归式。
- **主方法**：解决均分递归式，最常用。



### 最大子数组问题

寻找数组 $A$ 的一个**最大**的**非空连续子数组**。

买卖一次股票以获得最大收益时，将每天的**价格**，**变换**成每天的**涨跌值**，就将问题转化为了最大子数组问题。



递归主要思想是，最大子数组左右边界只有三种情况：

- **全在左面**：递归调用
- **全在右面**：递归调用
- **跨越中线**：从中间向两端找最大值，合并。

````c++
FindMaxCrossingSubarray(A,low,mid,high)
	leftSum = -infin
    sum =0
    for i = min downto low
        sum = sum+A[i]
        if sum>leftSum
           	leftSum = sum
            maxLeft = i
    rightSum = -infin
    sum =0
    for j = mid+1 to high
        sum = sum+A[j]
        if sum>rightSum
           	rightSum = sum
            maxRight = j
    return (maxLeft,maxRight,leftSum+rightSum)
            
FindMaximumSubarray(A,low,high)
    if high == low
        return (low,high,A[low])
    (leftLow,leftHigh,leftSum)=FindMaximumSubarray(A,low,mid)
    (rightLow,rightHigh,rightSum)=FindMaximumSubarray(A,mid+1,high)
    (crossLow,crossHigh,crossSum)=FindMaxCrossingSubarray(A,low,mid,high)
    if leftSum>=rightSum and leftSum >=crossSum
        return (leftLow,leftHigh,leftSum)
    elseif  rightSum>=leftSum and rightSum >=crossSum
    	return (rightLow,rightHigh,rightSum)
    elseif  crossSum>=leftSum and crossSum >=rightSum
    	return (crossLow,crossHigh,crossSum)
        
        
````



### 矩阵乘法 Strassen算法

普通矩阵乘法，使用逐行逐列相乘求和，$O(n^3)$。

普通分治思想，均分四块，分块矩阵乘法，$O(n^3)$。

Strassen算法，**均分四块**，之后先算10个子矩阵的和，之后再算4个子矩阵与10个和矩阵的7个矩阵乘，之后再把7个矩阵积组合成分块矩阵的正常结果。使用了**7次矩阵乘法**，而不是普通分块的8次，$O(n^{\lg7})$。

### 带入法求渐进复杂度

根据之前**类似结构**的算法的渐进效率，估计此算法可能的渐进效率，之后验证。

- **猜测**解的形式
- **数学归纳法**解出常数，证明正确性。

要选择合适的 $n_0$ ，因为在边界时，很容易出问题。

可以先猜一个比较大的上界，再慢慢缩小。



**较强的上界可能会比更较的上界更容易用数学归纳法证明**。如 $T(n)= 2T(n/2)+1$ 得到 $T(n)\leq cn$ :

若假设 $T(n)\leq cn$ ，则 $T(n)= 2T(n/2)+1 \leq 2cn/2 +1 = cn+1$ 。无法证明。

若假设 $T(n)\leq cn-d$ ，则 $T(n)= 2T(n/2)+1 \leq 2(cn/2 -d ) +1 = cn-2d+1\leq cn-d$ 。证明。



在证明时，需要证出与归纳假设严格一样的形式，**不能合并 $c$ 与常数**。如错误证明$T(n)= 2T(n/2)$ 得到 $T(n)\leq cn$ ：$T(n) \leq 2(c[n/2])+n \leq cn +n = O(n)$。

原因在于证出的是$T(n)\leq (c +1 )n$ ，虽然同阶，但不等。实际为$T(n)\leq n\lg(n)$。



可以适当变换变量形式，指数对数变换，方便证明。$T(n) = 2T([\sqrt{n}])+\lg (n)$， $m=\lg n$ ，$S(m)=2S(m/2)+m$ ，$S(m)=O(m \lg m)$， $T(n)=T(2^m)=S(m)=O(m\lg m) = O(\lg n \lg\lg n))$。

### 递归树求渐进复杂度

首先将递归结构展开成树的形式，之后计算每层的复杂度，再求和。用来估计最可能的渐进复杂度，之后用代入法证明。

### 主方法求渐进复杂度

用以求解 $T(n)=aT(n/b)+f(n)$ 型的递归式：



- 若 $f(n)=O(n^{\log_b{a-\epsilon}})$，则 $T(n)=\Theta(n^{\log_b{a}})$
- 若 $f(n)=\Theta(n^{\log_b{a}})$，则 $T(n)=\Theta(n^{\log_b{a}}\lg n)$
- 若 $f(n)=\Omega(n^{\log_b{a+\epsilon}})$，则 $T(n)=\Theta(f(n))$ 

直觉上就是**比较递归部分与函数部分的大小**。不等则为大的那个；相等则递归树变宽，乘 $\lg n$ 系数。



## 第5章 概率分析和随机算法





### 随机算法

一个算法的行为不仅由输入决定，还使用随机数生成器生成的**随机序列**决定，就称指为随机算法。

很多随机算法通过对输入进行随机排列。



### 概率分析

寻找一个随机算法的**平均情况运行时间**，也就是期望。



### 指示器随机变量

给定一个样本空间 $S$ ，一个事件 $A$ ，那么对应的**指示器随机变量**就是 $I\{A\} = \cases {1&true\\0 &false}$ 。



### 雇佣问题

面试，立即决定是否录用，选择最好的，计算录用次数。面试者的能力随机，是最简单的随机形式。

录用面试者次数期望是 $\lg n$ 。每次面试的面试者比前面所有人强的概率是 $p(i)=1/i$ ，所以期望 $E(X) = \sum_{i=1}^{n}(1/i) = \lg n$。

### 生日悖论

一群人中存在同一天生日的两人的概率大于一半需要最少多少人。$n$天，$k$人， 每个人不与前人重复的概率 $p(i)=(n-(i-1))/n$ 。$p(X) = \prod_{i=1}^{n}(n-(i-1))/n \leq e^{-k(k-1)/2n} $。

### 球与箱子

$b$ 个箱子，每次投球必中一个箱子。

问多少个求落在指定的箱子内。$E(X) = n/b$。

问所有箱子都有球，投掷的次数的期望，第 $i$ 个箱子进入的概率为 $p(i)=(1-(i-1)/b)$ ，就是扔到已有球箱子概率的补； $E(X) = \sum_{i=1}^{b}1/(1-(i-1)/b) = b\ln b$。



### 特征序列

抛硬币连续正面的**特征序列**的长度期望是 $\Theta(\lg n)$。利用不等式求上界。       

$p(i) = 1/2^i$ ， 对于 $k=2\lg n$ ，$p(k)=1/2^{2\lg n} = 1/n^2 $ 。也就是说，对于目标特征序列长度为 $2\lg n$ 的概率为 $ 1/n^2 $ ，但是整个长度为 $n$ 的情况下，一共有 $n- 2\lg n$ 个位置有可能达到这个长度，即长度为 $2\lg n$ 的概率为 $(n- 2\lg n    )*1/n^2  = 1/n$  。所以总期望为 $E(X) = \sum_{i=1}^{n}(1/i) = \lg n$ 。



### 在线雇佣问题

求在给定选中最好的员工的概率下，选择的策略。前 $k$ 个中，记录最好的人，之后的 $n-k$ 个中，只要遇到比前 $k$ 个最好的更好的人，就选择这个，求 $k$ 的值。

首先最好的在前 $k$ 个中一定选不到，而在后  $n-k$ 个中时，需要排在其前面的都小于前 $k$ 个最好的，概率为 $p(i) = (k)/(i-1)$ ，所以在 指定 $k$ 的情况下，选到最好的概率为 $E(X) = \sum_{i=k+1}^{n} (k)/(i-1) \leq k/n (\ln (n-1) - \ln (k-1)) $



## 第二部分 排序和顺序统计量



| 算法 |       最坏        |       平均        |
| :--: | :---------------: | :---------------: |
| 插入 |   $\Theta(n^2)$   |   $\Theta(n^2)$   |
| 归并 | $\Theta(n\lg n)$  | $\Theta(n\lg n)$  |
|  堆  | $\Theta(n\lg n)$  |                   |
| 快速 |   $\Theta(n^2)$   | $\Theta(n\lg n)$  |
| 计数 |  $\Theta(k+ n)$   |  $\Theta(k+ n)$   |
| 基数 | $\Theta(d(k+ n))$ | $\Theta(d(k+ n))$ |
|  桶  |   $\Theta(n^2)$   |    $\Theta(n)$    |



## 第6章 堆排序

### 堆

近似的**完全二叉树**，可以使用数组、结点等物理结构。通常使用数组，方便计算。

最大堆就是最大值在堆顶。结点元素大于子结点元素。

原址算法。

可以实现优先队列。

### 从上至下维护

若结点的所有子结点都是堆，只有此结点元素是新加入的，需要从上到下维护，使其成堆。

方法是：比较结点元素与子结点元素，若大于所有子结点元素，无需操作。否者将最大元素与此结点元素互换，之后继续维护互换后的子结点。

### 从下至上维护

若结点的父结点都是堆，只有此结点元素是新加入的，需要从下到上维护，使其成堆。

方法是：比较结点元素与父结点元素，若父结点元素大于此结点元素，无需操作。否者将父结点元素与此结点元素互换，之后继续维护互换后的父结点。

### 建堆

使用从上至下维护的方法，可以从底向上的建立一个堆；

### 移除

去掉堆顶，移动最后一个到堆顶，从上至下维护。

### 添加

添加最后一个，从下至上维护。





## 第7章 快速排序

### 快速排序

原址排序。最坏情况很差，但平均很好，**实际中很好**。



- 分解：选择一个数，将数组分成大于其与小于等于其的两组。
- 解决：递归调用，或规模很小时，直接求解。
- 合并：原址，不需要操作。



````c++
Partition(A,p,r)
    x= A[r]
    i=p-1
    for j = p to r-1
        if A[j]<x
            i++
            exchange A[i] with A[j]
    exchange A[i+1] with A[r]       
    return i+1
QuickSort(A,p,r)    
    if p<r
        q = Partition(A,p,r)
        QuickSort(A,q+1,r) 
        QuickSort(A,p,q-1) 
        
````



循环不变式

- 初始化：空，成立
- 保持：每次交换，交换后，左边的都是比目标值小，而右边的时比目标值大的。成立。
- 终止：必然成立。



最坏情况为选择的主元素是范围内最值，退化为冒泡排序，因为每次只选中了最值，而问题规模只减少1。

最好情况为选择的主元素是范围内中位数，类似归并排序。

## 第8章 线性时间排序

### 排序算法的下界

比较排序，最快$\Theta(n\lg n)$，好的方法也就是在常数项上优于归并和堆。

基于运算的排序，可以达到线性时间。

### 决策树模型

一棵完全二叉树，枝干结点是**输入序列两个位置比较运算操作**，子树是**对应结果的分支**，叶子结点存储结果。

每一个比较排序都可以生成一棵决策树，共有 $n!$ 个排列的叶子结点。

最坏条件下需要比较$\Theta(n\lg n)$ 次。

### 计数排序

对于每个输入元素，确定小于其的元素个数，这样可以直接排序了。若 $k=O(n)$ ，则**以空间换时间**。

其实可以不统计个数，直接按照是否有值来进行排序。

````c++
CountingSort(A,B,k)
    let C[0..k]
    for i =0 to k
        C[i] =0
    // 看哪一位上有值
    for j=1 to A.length
        C[A[j]]=C[A[j]]+1
    // 统计小于其的元素个数
    for i =0 to k
        c[i]=c[i]+c[i-1]
    for j =A.length downto 1
        // 输出数组中A[j]元素个数位置
        B[C[A[j]]] =A[j]
        C[A[j]]=C[A[j]]-1
      
````

###  基数排序

特定使用场景，卡片机。$n$ 个卡片，表示多少个数字；每个卡片 $d$ 行，表示多少位；每行 $10$ 个空，表示多少进制。

**从低位向高位排列，每次将此位上大的放在前面。**

### 桶排序

假设输入为 $[0,1)$ 的数，之后将元素与输入序列长度相乘取整，得到元素桶的索引，这样把**每个元素分到了对应的桶中**，桶的顺序就是元素原来的顺序，**再在桶中排序**，降低问题规模。

最坏情况为所有元素分到了一个桶中，退化成了插入排序。

最好情况为所有元素都不在一个桶中，进化成了基数排序。但又省了空间。

平均情况，$n_i$ 表示第 $i $ 个桶中元素个数，$E(X) = \Theta(n) + \sum_{i=1}^n O( n_i^2)$，可以断言 $E(  n_i^2)=2-1/n$，所以 $E(T(n))=\Theta(n)$。

证 $E(  n_i^2)=2-1/n$：

设 $X_{ij}=I\{A[j]\in \mathrm{Bucket}[i]\}$ ，则

$n_i=\sum_{j=1}^nX_{ij}$ ，展开得到$E(n_i^2)=E(\sum_{j=1}^nX_{ij}^2+\sum_{j=1}^n\sum_{k=1,k\neq j}^nX_{ij}X_{ik})$  ，分别求期望，$E(X_{ij}^2)=1/n$   ，$E(X_{ij}X_{ik})=1/n^2$  ，合并 $E(n_i^2)=E(\sum_{j=1}^nX_{ij}^2+\sum_{j=1}^n\sum_{k=1,k\neq j}^nX_{ij}X_{ik})=n*1/n+n(n-1)*1/n^2=2-1/n$。

````c++
BucketSort(A)
    n=A.length
    let B[0..n-1]
    for i =0 to n-1
        B[i]= list
    // 分在不同的桶中
    for i =1 to n
        B[i].add(nA[i])
    for i =0 to n-1
        InsertingSort(B[i])
    concatenate B[0..n-1]
````



## 第9章 中位数与顺序统计量



### 顺序统计量

第 $i$ 个顺序统计量，就是该集合中第 $i$ 小的元素。

### 最值

在一个 $n$ 元素集合中，多少次比较才能找到最值。上界是 $n-1$，下界也是 $n-1$。

那么同时找到最大值与最小值需要多少次比较，直观上界是 $2n-2$，实际可以是$3[n/2]$。方法是记录前两个值为最值，之后成对比较，之后较小的与最小值比较，较大的与最大值比较。

### 线性时间选择算法

利用**快排思想**，每次将输入分为两部分，看两部分的元素数量与目标位置的关系，确定目标在哪部分中，递归。

最坏情况是每次只剔除了区分元素，退化成了选择排序。

平均情况是，太复杂。大意是，主元的位置是随机的，并假设每次目标都在数量多的区域中，之后求期望。

````c++
//返回数组A p-r索引中，第i小的元素
RandomizedSelect(A,p,r,i)
    if p==r
        return A[p]
    // 快排中的分区域，返回的是选中的区分元素的下标
    q = RandomizedPartition(A,p,r) 
    k = q-p+1
    // 恰巧区分元素是第i小的
    if i== k
        return A[q]
    // 左面    
    else if i<K
        return RandomizedSelect(A,p,q-1,i)
    // 右面       
    else
        return RandomizedSelect(A,q+1,r,i-k)
        
````

### 最坏情况为线性时间的选择算法



- 划分为 $n/5$ 组
- 找每一组的中位数
- 对这些中位数递归调用求中位数
- 按照找到的中位数对原输入进行划分
- 根据区域数量进行递归调用



因为每次划分的依据都是**中位数的中位数**，所以至少有 $((n/5 )/2-2)*3 = 3/10 *n+6$ 个数据被剔除。

先猜，后数学归纳法验证。

$T(n) = T(n/5 ) + T(7n/10+6) +O(n)$，设其为线性， $T(n)\leq cn$ ，则可以推出 $T(n)\leq cn/5+c+7cn/10 +6c +an =cn +(-cn/10 +7c+an)$ ，只要满足  $c\geq 10a(n/(n-70))$ 即可成立。



## 第三部分 数据结构

动态集合的元素

动态集合上的操作



## 第10章 基本数据结构



### 栈

后进先出

栈下溢：在空栈中取出元素

栈上溢：向满的栈中添加元素



### 队列

先进先出

- 普通队列。

- 循环队列。

### 链表

线性排列

链表的顺序是由结点中的指针确定的，而不是物理位置。可以使用数组，用索引来模拟链表指针。

- 单向链表
- 双向链表
- 循环链表
- 非循环链表



### 有根树

可以使用数组来模拟树，特别是二叉树，可以很好的模拟，不用使用除元素外的额外引用空间。

而多分支的结构需要额外索引。



## 第11章 散列表



### 直接寻址表

从关键字全域中直接找到数组中的索引，数组中存储链表指针，之后链表存储卫星数据。每个全域中的元素对应一个数组中的索引，当全域很大时，数组也很大。

实际上就是一个单纯的数组，索引。

### 散列表

实现字典的一种有效数据结构。最坏 $\Theta(n)$ ，平均实际 $O(1)$ 。

实际上使用的关键字比全域中要少很多，使用**杂凑函数将关键字全域映射到一个较小的散列值域中。**

两个关键字可能映射到一个散列值中，使用一些方式处理：

- 链接法：同一个槽中使用链表存储卫星数据。效率低。
- 开放寻址法：如果槽中已有数据，按照算法计算下一个位置，形成探查序列。
  - 线性探查： $h(k,i)=(h'(k)+i) \mathrm{mod} m$
  - 二次探查： $h(k,i)=(h'(k)+c_1i+c_2i^2) \mathrm{mod} m$
  - 双重散列： $h(k,i)=(h_1(k)+ih_2(k)) \mathrm{mod} m$

- 完全散列：两级散列，第二级散列的大小不同，根据槽内的元素数量指定大小。$m_i=n_i^2$。空间 $O(n)$，时间 $O(1)$，



## 第12章 二叉搜索树



### 二叉搜索树

每一个结点有元素、卫星数据外，还有三个指针，分别指向父结点、左子结点、右子结点。

**左子树上所有元素都小于等于此结点元素，而右子树上所有元素都大于此结点元素。**



基本操作

- 插入
- 搜索
- 删除
- 最小值
- 最大值
- 前驱
- 后继



迭代展开比递归快。

### 插入与查询

根据元素大小关系，判断是在左子树还是右子树。



### 遍历

指的是，访问此结点元素是与访问左右子树的关系。

- 前序遍历
- 中序遍历
- 后序遍历



### 前驱与后继

按照遍历顺序，查找。



### 删除

删掉结点元素，如果有子树，需要递归移动。会导致树的高度及结构变化。



### 随机构造二叉搜索树

按照随机次序输入关键字到一棵初始为空的树。

- 指数高度：树的高度作为指数，$Y_n=2^{X_n}$ 
- 秩：树根元素在树中的排序索引。







## 第13章 红黑树



这个地址上讲的比算法导论要好。

[Red-Black Trees | Deletion](https://www.codesdope.com/course/data-structures-red-black-trees-deletion/)



### 红黑树

每个结点上有一个存储位来表示结点的颜色，通过对从根到叶子的简单路径上各个结点的颜色进行约束，保证没有一条路长度不是另一条的两倍。



根结点是黑色的，叶结点也是黑色的。

红色结点的子结点必须是黑色的，反之不然。

从一个结点到其所有叶子结点的黑色结点个数相同。



结点的五个属性：

- 颜色
- 元素
- 左结点指针
- 右结点指针
- 卫星数据指针



黑高：一条简单路径中黑色结点的数量。

使用哨兵结点，即所有为空的指针都指向这个结点。



### 旋转

右旋：把左子结点旋转到父结点的位置上，**原左子结点的右结点**成为**原父结点的左子结点**，**原父结点**成为**原左子结点的右结点**。

左旋：把右子结点旋转到父结点的位置上，**原右子结点的左结点**成为**原父结点的右子结点**，**原父结点**成为**原右子结点的左结点**。



### 插入



````c++
RBInsert(T,z)
    y = T.nil
    x = T.root
    // 找到合适的位置
    while x != T.nil
        y = x
        if z.key <x.key
            x = x.left
        else
            x = x.right
    // 插入
    z.p = y
    if y == T.nil
        T.root = z
    elseif z.key < y.key 
        y.left = z
    else 
        y.right = z
    // 设置
    z.left = T.nil
    z.right = T.nil   
    z.color = RED
    
    RBInsertFixup(T,z)
        
RBInsertFixup(T,z)        
    while z.p.color == RED
        if z.p == z.p.p.left
            y=z.p.p.right
            // 如果父结点和父结点的兄弟结点都是红的，就把这两个结点变黑，
            // 父结点的父结点变红，之后改变z为父结点的父结点，迭代。
            // 若此区域代码运行结束后，z为root，那么此树的黑高会增加，由最后算法最后一句实现
            if y.color == RED
                z.p.color = BLACK
                y.color = BLACK
                z.p.p.color = RED
                z = z.p.p
            else
                // 如果是父结点的右子结点，那么需要左旋，将父结点的右子结点变为空，或黑树。
                if z == z.p.right
                    z = z.p
                    LeafRotate(T,z)
                // 之后改变父结点颜色，并右旋，这一步将爷爷结点移动到了其右子树的位置，父结点成为爷爷结点的父结点。
                z.p.color = BLACK
                z.p.p.color = RED
                RightRotate(T,z.p.p)
     	else
         	same as then clause with right and left exchanged
  	T.root.color = BLACK
             
        
````



### 删除





````c++
// 把u换成v。
RBTransplant(T,u,v)
    if u.p == T.nil
        T.root = v
    elseif u == u.p.left
        u.p.left = v
    else 
        u.p.right = v
    v.p = u.p    
        
RBDelete(T,z)
    
    y = z
    yOroginalColor = y.color
    // 左为空，那么就可以直接替换    
    if z.left == T.nil
        x = z.right
        RBTransplant(T,z,z.right)
    // 右为空也一样
    elseif  z.right == T.nil
        x = z.left
        RBTransplant(T,z,z.left)
    // 都不为空，就需要找一个位置能放下两棵子树了。
    // y是z的后继，使y代替z的位置
    else
        // y是右子树中最小的
        y = TreeMinimun(z.right)
        yOroginalColor = y.color
        x = y.right
        // z的右子树根结点最小的就是根结点，
        // 也就是右子树没有左子结点，那么就可以把z的左子树直接放在这了。
        if y.p == z
            x.p = y
        // 如果不是，那么就需要将把y移到z的右子结点位置上
        // 首先将y的右子树移到y的位置上，由于y是最小的，一定没有左子树
        // 之后将y提到z的右子树位置上。
        else 
            RBTransplant(T,y,y.right)
            y.right  = z.right 
            y.right.p = y
        // 使用y替换z
        RBTransplant(T,z,y)    
        y.left = z.left
        y.left.p = y
        y.color = z.color
    // 因为使用y替换了z，所以如果y是黑色的，那么就会破坏结构
    // 而x是替换了y的位置，所以要检测x
    if yOroginalColor == BLACK
       	RBDeleteFixup(T,x)
       
RBDeleteFixup(T,x)   
    // 主要问题是原来y的位置，现在x的位置，原本是一个黑色的
    // 那么移动y之后，就少了一个黑色的
    // 就是要迭代处理这个问题
   	while x != T.root and x.color == BLACK
       	if x == x.p.left
            w = x.p.right
            // 如果兄弟结点是红色的，那么就说明父结点是黑色的，
            // 那么只需要交换兄弟结点与父结点的颜色，之后左旋
            // 但是没有改变少一个黑色结点的问题，而是转化为了其他情况
            // 即父结点为红色结点的情况，此树少了一个黑色，而兄弟树没有少
            if w.color == RED
                w.color = BlACK
                x.p.color = RED
                LeafRotate(T,x.p)
                w = x.p.right
            // 此时兄弟结点一定是黑色的了
            // 如果兄弟结点的子结点都是黑色的，就可以将兄弟结点变红，
            // 这样兄弟结点也少了一个黑色
            // 将矛盾上移，因为没有红色结点可以变为黑色，以恢复红黑树
            if w.left.color == BLACK and w.right.color == BLACK
                w.color = RED
                x = x.p
            else 
                // 如果兄弟结点的右结点为黑色，而左结点为红色
                // 那么就可以换色，右旋，使兄弟结点为黑色，
                // 而兄弟结点的右子结点为红色
                if w.right.color == BLACK
                    w.left.color = BLACK
                    w.color = RED
                    RightRotate(T,w)
                    w = x.p.right
                // 兄弟结点的右子结点为红色
                // 设置颜色后，左旋，这样对于x来说，额外多出了w的黑色，
                // 而w上没有多出黑色，完成修复
                // 本质上是，w的右子结点上的红色变黑，代替w的黑色，
                // x的父结点变成w的黑色，额外补全的缺的一个黑色。
                // w的变成x的父结点的颜色，代替了x的父结点，  
                w.color = x.p.color 
                x.p.color = BLACK
                w.right.color = BLACK
                LeafRotate(T,x.p)
                x = T.root
        else 
           same as then clause with right and left exchanged 
    // 由于x这个子树上缺了一个黑色，如果因为x为红色跳出时，直接变黑即可        
    x.color = BLACK
````











## 第14章 数据结构的扩张



### 动态顺序统计

修改红黑树，使其可以动态地在对数时间内确定任何的顺序统计量。



顺序统计树，在红白树的基础上，**每个结点多一个属性**，用来标记包括此结点在内的子树上所有的结点个数。

确定一个元素的秩，即位置索引。

### 如何扩张数据结构

- 选择一种数据结构
- 确定数据结构中要维护的附加信息
- 检验基础数据结构上的基本修改操作能否维护附加信息
- 设计一些新操作



### 区间树

关键字为区域的最小值，附加信息为子树中的最大值。



## 第四部分 高级设计与分析技术





## 第15章 动态规划

### 动态规划

动态规划与分治法类似，都使用**组合子问题的解**来解决原问题。

分治法通常划分的子问题都是不重复的，而动态规划划分的子问题有很大一部分都是重复的，所以需要一个表来存储各个子问题的中间结果，这**需要额外的空间**。

动态规划通常用来求解**最优化问题**。最优化问题即解决这个问题有很多不同的解，每个解都有一个值，要找到值最优的那个解。



- 刻划一个最优解的结构特征
- 递归地定义最优解的值
- 计算最优解的值，通常自底向上的方法
- 利用计算出的信息构建一个最优解



**最优子结构**：问题的最优解由相关子问题的最优解组合而成。



### 钢条切割

将一条长钢条切割成短钢条，不同长度的短钢条价格不同，切割没有成本，找到最优的切割方法所对应的价格。

当长度为 $n$ 时，有 $n-1$ 个位置可以切断，用一个数组存放长度为索引值时的最优价格，那么就可以比较在**不同位置切割的最优价格和不切割的价格**，来选择一个最高值。这也就是其的最优子结构。

迭代求解。



如果使用分治法，递归求解，那么就会有很多**重复子问题**，即同一长度的最优值被重复计算。

动态规划本质上就是带备忘录的分治法。

所以动态规划有两种形式：

- 自底向上的**动态规划**
- 自顶向下的**备忘录**



每个结点额外保留一个分割点信息，就可以得到具体的分割位置。



### 矩阵链乘法

多个矩阵相乘，先计算任意两个连续的矩阵乘法都不影响结果，是完全括号化的。

**完全括号化的**：在一系列元素的计算中，先计算任意两个连续的元素都不影响结果。



由于矩阵乘法不同顺序执行时，矩阵的**规模**会不同，会影响计算效率，找到最好的计算顺序。



- **结构特征**：可以分为左右两个矩阵链，+设左矩阵为 $s\times m$ ，右矩阵为 $m\times n$ ，那么代价为 $s\times m \times n$ 加得到左右矩阵的计算量。
- **递归求解方案**：对于一系列乘法，可以在任意位置加括号分割成两个系列乘法.
- **计算最优求解代价**：比较不同位置的代价，选择最优的，记录位置
- **构造最优解**：通过计算最优解时记录的位置，构造最优解。



由于这个需要记录每一个计算位置，所以不能使用一个一维数组存储中间结果。

使用一个二维数组，第一维表示数组的长度，第二维表示索引时1最小的计算量。

即第一行全为0，第二行，第一列元素为第一个矩阵与第二个矩阵相乘的计算量；第二个元素为第二个矩阵与第三个矩阵相乘的计算量；共 $n-1$ 列。

是一个金字塔型结构。



### 动态规划原理



**最优子结构**：一个问题的最优解包含其子问题的最优解。

**剪贴粘贴技术**：如果一个问题的最优解不包含其子问题的最优解，那么就可以将问题最优解的解法去解子问题，这与假设不服。



**重叠子问题**：递归算法会反复求解相同的问题。



**重构最优解**：在计算子问题最优解时，需要保存代价及计算过程，以恢复最优解。



**备忘**：对递归算法加入备忘机制，维护一个表记录子问题的解。



### 最长公共子序列

DNA中碱基对，需要确定两条DNA的相似度，使用最长公共子序列定义的相似度。

最长公共子序列：一个子序列在两个序列中都出现，且顺序相同，但不要求连续。



- 特征：前缀，
  - 如果两个序列在最后一个元素相同，则最长公共子序列就是这两个序列除最后一个元素外的**前缀序列**的最长公共子序列**长度加一**。
  - 如果两个序列在最后一个元素不同，则最长公共子序列就是这两个序列除最后一个元素外的**前缀序列**与另一个**序列**的最长公共子序列**长度**。
- 递归解：可以递归剔除最后一个元素求解。
- 计算：根据特征条件计算
- 构造：看是哪一步增加的，就是这个元素。



### 最优二叉搜索树



希望搜索次数多的元素的高度比较低，这样效率高。

给定一个已排序序列，每个元素都有一个查询概率，还有 $n+1$个 伪元素，表示无值，放在叶子结点位置上。设计二叉树，使其**搜索时间期望最小**。



- 结构：如果此树是最优二叉搜索树，那么其左右子树都是最优二叉搜索树。
- 递归算法：对于一个序列，可以从任意位置分为三部分，一个元素，左右两个子树。
- 计算代价：搜索**元素代价**加**左右子树代价**加**左右子树概率**，左右子树概率的含义为树结点深度加1，代价额外增多 **左右子树概率*1**。需要保存分割位置，总访问概率，代价期望。
- 构造：递归构造



也是一个**金字塔型结构**。





## 第16章 贪心算法



### 活动选择问题

有$n$ 个**活动**，**竞争共用资源**，不可同时使用，每个活动有**起始时间**与**结束时间**，求在**规定时间**内**最多的活动数**计划。

- 最优子结构：最优的安排可以按照其活动的一个间隔**划分为两段**，在这两段上的计划**包含每段上的最优计划**。
- 贪心选择：可以直接选择兼容的**结束时间最早的活动**，因为结束时间比其晚的会占用更多的时间。



两种形式：

- 递归贪心算法
- 迭代贪心算法

**迭代就是递归的展开。**



### 贪心选择原理



总是做出**当前最优的选择**，并组合成最优解。通常是自顶向下的。



步骤：

- 将最优化问题转化为**贪心形式**：对其做出一次选择后，只剩下一个问题需要求解。
- 证明贪心选择的**安全性**：做出贪心选择后，原问题存在最优解。
- 证明**最优子结构**：使用复制粘贴技术，证明最优解与贪心选择的组合和可以得到原问题的最优解。



**0-1 背包**问题**不能**使用贪心算法，而**分数背包**问题**可以**使用贪心算法。



### 赫夫曼编码



**定长编码**：每个字符都使用**固定长度**的编码。

**变长编码**：**频率高**的字符使用的编码**长度短**，反之则长。



**前缀码**：变长编码，**没有**一个字符的编码是另一个字符的编码的**前缀**。

**编码树**：构造前缀码。叶子结点上为字符，左为0，右为1，前缀就是唯一的。

**赫尔曼夫编码**：一种**前缀码**，使用贪心算法构造**编码树**，进而构造**前缀码**。使用递归思想，**自底向上**构造，每一步选择两个概率最小的结点，构造一个结点，**此结点的概率为子结点概率和**，使用**队列**，深度优先构造二叉树。



````c++
Huffman(C)
    n = |C|
    for i = 1 to n-1
        allocate a new node z
        z.left = x = ExtractMin(Q)
        z.right = y = ExtractMin(Q)
        z.freq = x.freq + y.freq
        Insert(Q,z)
    // 每一次弹出两个结点，插入一个结点，即减少一个结点，    
    // 最后就剩一个根结点
    return ExtractMin(Q)
````



### 拟阵



描述了很多贪心算法生成最优解的情形。

**拟阵**：是**序偶** $M=(S,T)$ 

- $S$ 是一个有限集
- $T$ 是 $S$ 的子集的一个非空族，**独立**子集。如果 $B\in T$ $A \subseteq B$ 则 $A\in T$ ，则称 $T$ 是**遗传的**。
- 若  $A\in T$ ， $B\in T$ 且 $|A| < |B|$ ，那么 $\exist x \in B-A$ ， 使$ A \cup \{x\} \in T$ ，则称 $M$ 满足**交换性质**。



**图拟阵**： $M_G=(S_G,T_G)$ ，$G=(V,E)$

- $S_G$ 为 $E$
- 若 $A\in E$ ，则 $A \in T_G$ ，当且仅当 $G$ 是无圈的。

 

拟阵中所有最大独立子集具有**相同**的大小。



如在**最小生成树问题**中，给定一个连通无向图 $G=(V,E)$ ，和一个长度函数 $w$ ，$w(e)$ 表示边 $e$ 的长度。

希望找到一个边的子集，能连接所有的顶点，且具有最小的总长度。

权重指的是关联的拟阵的权重。

考虑加权拟阵 $M_G=(S_G,T_G)$ ，其权重函数为 $w'(e) = w_0-w(e)$，$w_0$ 为长度最长的边。

拟阵的最优子集为原图中最小总长度生成树。



**找到最大权重独立子集的问题。**



````c++
Greedy(M,w)
    A = empty set
    sort M.S into monotonially decreasing order by widget w
    for each x in M.S ,taken in monotonially decreasing order by weight w(x)
        // 因为T是无圈的，在内说明没有圈
        if A merge {x} in M.T
            A =  A merge {x}
	return A
````



### 任务调度

处理器上的执行任务。

单位时间任务：严格需要一个时间单位来完成作业。



单处理器上带截止时间和惩罚的单位时间任务调度问题：

- $n$ 个单位时间**任务**的合集 $S=\{a_1,a_2,\cdots,a_n\}$.
- $n$ 个整数的**截止时间** $d_1,d_2,\cdots,d_n$ ，期望任务$a_i$ 在时间 $d_i$ 前完成。
- $n$ 个非负的惩罚 $w_1,w_2,\cdots,w_n$， 若任务$a_i$ 没有在时间 $d_i$ 前完成，就会受到 $w_i$ 的**惩罚**。

期待找到一个**最小惩罚**的调度顺序。



如果一个任务在截止时间之后完成，则称其为**延迟的**，否则为**提前的**。

对于任意调度方案都可以转化为**提前优先形式**，即提前的任务都在延迟的任务之前完成，因为不在之前的话，就可以互换这两者。

**标准形式**为**提前优先形式**后，把所有**延迟**任务以**任意顺序**排在**提前**任务**之后**。



若$S$是一个给定截止时间和惩罚的单位时间**任务集合**，$T$ 是所有**独立任务集合的集合**，则对应的系统 $(S,T)$ 是一个**拟阵**。



使用 `Greedy` 算法，可以在 $O(n^2)$ 时间内得到最优调度。因为执行了 $O(n)$ 次独立性检查，每次耗时  $O(n)$ 。**还是有问题**。                                               

可以**以时间从后向前搜索**，每次检索的是在此时间可以完成的任务，选择最大权重的。

​                                                                                                                                                                           

## 第17章 摊还分析 amortized analysis



**最差情况**下的每个**操作**的**平均性能**。



### 聚合分析 aggregate analysis

证明对所有的 $n$ ，一个 **$n$ 个操作的序列**，**最坏情况**下花费的**总时间为** $T(n)$，因此在最坏情况下，每个操作的**平均代价**，或称**摊还代价**为 $T(n)/n$。



**栈操作**：

当有两个操作的时候：

- $Push$： $O(1)$
- $Pop$： $O(1)$

显然**$n$ 个操作的序列**，**最坏情况**下花费的**总时间为** $O(n)$，每个操作的**平均代价**，或称**摊还代价**为 $O(1)$。

当添加另外一个操作时：

- $MultiPop(S,k)$：弹出 $k$ 个， 最坏情况下全弹出，$O(n)$。

那么朴素的想法，因为有一个操作是$O(n)$，那么 $n$个操作**最坏情况**是 $O(n^2)$ 。

但实际上，利用**聚合分析**，在一个空栈上执行$n$个操作，一定**不可能全是**$O(n)$ 复杂度的，因为 $Push$ 一个，只能 $Pop$ 一次，所以 $Push$ 至少**占一半**，所以总时间最坏是 $nT(1) + 1T(n)$ ，**摊还代价**是 $O(1)$。



**二进制计数器递增**

加一，满二进一。

- $Increment(A)$ ，最差情况下，每一位都会进一，但其长度为 $\lg n$，$O(\lg n)$。

朴素最坏执行$n$个操作是 $O(n\lg n)$。

但实际上并不是每次都是$O(\lg n)$ 复杂度，**计算总反转位数**，最后一位每次都反转，而右侧第二位没两次才反转一次，而第三位每四次反转一次，所以总次数为 $\sum_{i=0}^{\lg n}[n/w^i] < n \sum_{i=0}^\infin 1/2^i = 2n$ 。所以**摊还代价**为 $O(n)$。





### 核算法 accounting method

对每个**操作赋予一个费用**，称为其的**摊还代价**；当一个操作的实际代价**小于**摊还代价时，将**差值存入**数据结构中的特定对象，称为**信用**。若实际代价**大于**摊还代价，则**取出信用**，信用不能为负。



**栈操作**

实际：

- $Push$ ：1
- $Pop$ ：1 
- $Multi Pop$ ：$\min (\lg n,s)$

费用：

- $Push$ ：2
- $Pop$ ：0
- $Multi Pop$ ：0

**因为每个 $Push$都会积累一个信用，在 $MultiPop$ 时消耗掉。**



**二进制计数器递增**

每一次操作的**费用为 $2$** ，那么，如果只反转一次，就会**积累一个信用**，这个信用**用于反转回去**，所以每一个为1的位，都会有一个费用使其反转回0，所以摊还代价为 $O(1)$。



### 势能法 potential method



与核算法相比，不是将多余费用存储于特定结构，为信用；而是**存在数据结构**中，表示为势能，用来**支付未来操作的代价**。



设 $D_i$ 为执行完第 $i$ 个操作得到的数据结构，势函数 $ \Phi(D_i)$ 为此数据结构的势能。第 $i$ 个操作用的摊还代价用势函数定义为 $\hat{c_i}=c_i +\Phi(D_i)- \Phi(D_{i-1})$ 。总摊还代价为 $\sum_{i=0}^{n}\hat{c_i}=\sum_{i=0}^{n}c_i +\Phi(D_n)- \Phi(D_{0})  $ 。$ \Phi(D_{0}) =0 $ 。



**栈操作**

定义**势函数为栈中元素数量**。

费用：

- $Push$ ：$\hat{c_i}=c_i +\Phi(D_i)- \Phi(D_{i-1}) = 1+1 = 2$
- $Pop$ ：0
- $Multi Pop$ ：0



**二进制计数器递增**

定义**势函数为位为1的数量**。

每一次操作的**费用为 $2$** 。



### 动态表 dynamic table



线性表，随着元素的增减，**动态分配空间**。虽然有些操作的代价很高，但**摊还代价是 $O(1)$ 的**。



**装载因子 $\alpha(T)$** 为表中存储的**数据量除以表的规模**。



- **表扩张**：当 $\alpha(T)>1$，即表满的时候，表容量扩充为原来的两倍。$O(n)$，然而并没事每次插入都调用，只有是2的幂次时才调用，扩充总代价为 $\sum_{i=0}^{n}{c_i}< n + \sum_{j=0}^{\lg n}{2^j} = 3n  $ ，即**每次新扩充的容量除了满足本身消耗外，还需给包括本身与原有的所有容量一个势能，用来支付下次的扩充**。
- **表收缩**：当 $\alpha(T)<1/4$，即表不满四分之一时，表容量缩小为原来的一半。**缩小的一半的势能，用来支付收缩的代价，保留的一半上的势能备用。**



所以摊还代价为 $O(1)$ 。



## 第五部分 高级数据结构



## 第18章 B 树



B 树在**降低磁盘IO 操作**要比红黑树好，数据库系统使用B 树，或其变种存储信息。

B 树的结点可以有很多孩子，其**大小通常与磁盘单元相同**，以减少IO 操作。

由于结点多，所以其**高度很低**。



### B 树定义

B 树，关键字元素和所有卫星数据都**存储在结点上**。

每个结点有**标志位**指示其**是否为叶子结点**。

结点若有 $n $ 个关键字， 则会有 $n+1$ 个子结点指针。

叶子结点具有**相同的深度**，即树的高度 $h$ 。

每个结点包含的关键字**个数有上界和下界**。**最小度数** $t$ ，元素个数最少为 $t-1$ 个，最多为 $2t-1$个。

高度与最小度数的关系：$h \leq  \log _t \frac{n+1}2$ ，因为根结点至少有一个子结点，而其他结点都至少有 $t-1$ 个，累加起来，等比数列求和。



B+ 树，所有的卫星数据都存储在**叶子结点**上。



###  基本操作



- 搜索：树的搜索推广，$O(t)$ 。
- 创建：$O(1)$。
- 插入：如果一个结点满了，那么就把这个**结点分裂成两个结点**，插入到父结点中，如果父结点也满了，继续分裂。实际中，是**从顶至下**操作，每次遇到满结点，就分裂这个结点，保证了要插入的结点不是满的，也就不用向上回溯了。
- 删除：关键字 $k$
  - 是叶子结点，直接删除
  - 是内部结点 $x$，
    - 找到位于 $k$ 前的子结点 $y$ ，如果 $y$ 的子结点个数大于等于 $t$ ，则在 $y$ 中找 $k$ 的**前驱** $k'$，替换，且递归删除 $k’$ 。
    - 否则，找位于 $k$ 后的子结点 $z$ ，如果 $z$ 的子结点个数大于等于 $t$ ，则在 $z$ 中找 $k$ 的**后继** $k'$，替换，且递归删除 $k’$ 。
    - 否则，合并 $y$ 与 $z$ ，删除 $k$ 后，移动 $x$ 的子结点指针。不用替换了。如果 $x$ 此时子结点数小于 $t$ ，需要其的兄弟结点向其移动一个子结点，如果都不够，就**合并**。**递归**。
    - 如果是根结点，且只有一个结点，就会降低树的高度。



​                           

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   

## 第19章 斐波那契堆

两种用途：

- 可合并堆
- 一些操作是常数摊还代价，适合于需要频繁调用的应用。



###  可合并堆

具有的操作

- $MakeHeap()$ ：创建一个空的堆，$\Theta(1)$
- $Insert(H,x)$ ：插入，$\Theta(\lg n )$ 
- $Minimum(H)$：最小值，$\Theta(1)$ 
- $ExtractMin(H)$：删除最小值，$\Theta(\lg n )$ 
- $Union(H_1,H_2)$：合并两个堆，$\Theta( n )$ 



而斐波那契堆

- $MakeHeap()$ ：创建一个空的堆，$\Theta(1)$
- $Insert(H,x)$ ：**插入**，$\Theta(1)$ 
- $Minimum(H)$：最小值，$\Theta(1)$ 
- $ExtractMin(H)$：删除最小值，$\Theta(\lg n )$ 
- $Union(H_1,H_2)$：**合并**两个堆，$\Theta( 1 )$ 
- $DecreaseKey(H,x,k)$：将 $x$ 替换为 $k$ ，其中 $k \leq x$，$\Theta(1)$ 
- $Delete(H,x)$：删除，$\Theta(\lg n )$ 



斐波那契堆的一些操作，摊还代价是常数，但**常数的值比普通堆要大**，实际情况中要具体分析。



### 斐波那契堆



一个**斐波那契堆**是一系列具有**最小堆序**的有根树的集合。每棵树都遵循**最小堆性质**。



结点属性：

- 父指针
- 子指针
- 左右兄弟指针：构成**兄弟双向链表**
- 度：孩子的数量
- 标志位：自从上一次成为另一个结点的孩子后，是否失去过结点



$H.min$ 指向树中**最小的结点**。

根链表，有根树的**根结点的双向链表**。



势函数： $\Phi(H) = t(h)+2m(H)$，$m(H)$ 为标记的结点数。

最大度数：$D(H)=O(\lg n )$。



### 插入与合并

插入：就是直接插入到根链表中，判断是否是最小值。

合并：将第二个堆的根链表合并到第一个堆中，找最小值。



### 抽取最小结点

是最复杂的一个操作。

把最小值的**所有孩子放到根链表**中，删去最小值，之后更新根链表，使根链表中，**每一个度的结点至多只有一个**，以减少结点。



具体做法是，使用一个大小为最大度数的数组，依次根据结点的度存储结点指针，一旦**一个度已有指针**，就**合并**这两个结点。做法就是以值较小的结点作为父结点，而**另一个结点作为其的子结点**，这样父结点的度就增加了，再判断这个度是否已经有结点。





### 关键字减值



将结点的关键字替换为指定的小于其值的值，之后判断其**新值是否大于其父结点**，若大于则对其进行切断操作，将其插入到根链表中，之后对父结点判断标志位，**若是假则标记**；若是真，则标记为假，并切断，插入到根链表中，**递归父结点**。



删除操作就是把结点的**值**设置为**负无穷**，之后**删掉**树中的**最小值**。



### 证明

黄金分割率 $\phi = (1+\sqrt{5})/2=1.61803...$

对于每一个结点，其度最多是插入树时的值减一，因为第二次失去子结点就又回到根链表中了。

$F(k) = F(k-1) + F(k-2)$

$F(k+2) = 1 + \sum _{i=0} ^k F(k)$

为什么叫斐波那契堆，因为在处理根链表，使其每个度最多有一个结点时，也使**所有结点的孩子的度是像斐波那契排列的，依次递减。**

​      



​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               



## 第20章 van Emde Boas 树



对于一些支持**优先队列**操作的结构，如**二叉堆**、**红黑树**和**斐波那契堆**来说，有些操作必须 **$O(\lg n)$** 时间来完成，因为其都是更具**关键字比较**来实现的。

对于关键字是**有界整数**时，如**基数排序**，就可以在 $O(1)$ 时间内完成一些操作。

对于关键字是**有界整数**且**不重复**时，van Emde Boas 树，其**所有操作最坏情况代价**为 $O(\lg\lg n)$。

记**关键字个数**为 $n$ ，**全域大小**为 $u$ 。



### 基本方法

无法达到 $O(\lg\lg n)$，但有助理解 van Emde Boas 树。

- **直接寻址**：一个长 $u$ 的数组，根据**关键字确定索引**。查询最小值与最大值，前驱后继的最坏代价是 $\Theta(u)$。
- **叠加的二叉树结构**：在**直接寻址的数组上叠加一个二叉树**，二叉树的叶子结点就是数组元素，每一个结点有一个标志位，**标记是否**其子树叶子结点有**存储**的关键字。此时上述四个操作的最坏代价是 $\Theta(\lg u)$。
- **叠加一棵高度恒定的树**：若叠加一棵度为 $\sqrt{u}$ 的树，那么高度就为2，是个确定值，每个结点具有 $\sqrt{u}$ 个子结点，称为一个簇。这样每次进行操作**最多需要访问三个结点，每个结点 $\sqrt{u}$ 代价**，所以此时上述四个操作的最坏代价是 $\sqrt{u}$，虽然比二叉树要差，但是其是 van Emde Boas 树的**重要思想来源**。



### 递归结构

对于一个簇来说，**朴素想法是直接遍历**，这样就浪费了很多时间。可以在每个簇上创建一个同样的结构，来**递归检索**关键字。

 这样每次递归都会把复杂度将为原来的 $\sqrt{t}$ 大小，使操作的最坏代价可以达到 $O(\lg\lg n)$。



### 原型 vEB 结构

$protoVEB(u)$ 递归定义：

- 一个全域大小 $u$ 。$u=2$ 时是基本大小。不是基本大小时，有以下属性。
- 一个 $summary$ 的指针，指向一个$protoVEB(\sqrt{u})$  结构。存储每一个簇上是否有值。
- 一个数组 $cluster[0..\sqrt{u}-1]$ ，存储 $\sqrt{u}$ 个指针，每一个指向一个$protoVEB(\sqrt{u})$  结构。存储簇的值。



操作时根据 $summary$ 的指针递归查找$cluster[0..\sqrt{u}-1]$。



由于一些操作需要递归两次，即查询 $summary$ 和查询$cluster[i]$ ，所以**最坏情况时代价**是 $O(\lg n)$。



### vEB 结构



在$protoVEB(u)$ 上多了最值属性，可以**通过最值属性，快速判断查询的关键子是否在这个簇中。**

$vEB(u)$ ：

- 一个全域大小 $u$ 。$u=2$ 时是基本大小。不是基本大小时，有以下属性。
- 一个 $summary$ 的指针，指向一个$protoVEB(\sqrt{u})$  结构。存储每一个簇上是否有值。
- 一个数组 $cluster[0..\sqrt{u}-1]$ ，存储 $\sqrt{u}$ 个指针，每一个指向一个$protoVEB(\sqrt{u})$  结构。存储簇的值。
- $min$ 存储最小值
- max 存储最大值

​                                                   

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        

## 第21章 用于不相交集合的数据结构

将 $n$ 个元素分成一组**不相交**的集合。

两个基本操作：

- 查找
- 合并



### 不相交集合的操作

一个**不相交集合数据结构**维护了一个**不相交动态集的集合** $S=\{S_1,S_2 ,\cdots,S_n\}$。

使用一个**代表**来表示每个集合。**代表**可以是动态集中**任意**元素，推荐为**最小元素**。



- $MakeSet(x)$：**创建**一个动态集，包含 $x$ 。
- $Union(x,y)$：**合并**包含 $x$ 与 $y$ 的两个动态集。
- $FindSet(x)$：**找到**包含 $x$ 的动态集。



一个应用就是找**无向图的连通分量**。



### 不相交集的链表表示

每个集合用一个链表表示，集合对象包括：

- $head$：指向第一个结点
- $tail$：指向最后一个结点

结点包括：

- $key$：关键字元素
- $next$：指向下一个结点
- $object$：指向集合对象

这样 创建动态集、找动态集都是 $O(1)$ 的。

然而 合并动态集 却是 $O(n)$ 的，因为需要更新另一个动态集中的**所有元素的集合对象指针**。



**加权合并**思路：总是把长度**较小**的链表合并到**较长**的中。

$m$ 个操作，其中 $n$ 个创建操作，需要耗时 $O(M+n\lg n)$ 。



### 不相交集合森林



使用二叉树森林，**每个结点只存储父结点的指针**，找动态集没有链表快，但是**渐进最优**。

改进**合并操作**运行时间的**启发式策略**：

- **按秩合并**：较少结点的树的根结点**指向**较多的树的根结点
- **路径压缩**：结点直接指向根结点。



### 带路径压缩的按秩合并的分析



对于 $k \geq 0$ ，$j \geq 1$ ，定义函数 $A_k(j) = \cases{j+1 \quad\quad\quad k=0 \\ A_{k-1}^{(j+1)} (j) \quad k \geq 1}$  。称 $k$ 为函数的阶。

有 $A_1(j) =2j+1$ , $A_2(j) = 2^{j+1}(j+1) -1 $  ，$A_3(1) = 2047$  ，$A_4(1) >> 10 ^{80}$。



定义其的逆函数 $\alpha(n) = \min \{k:A_k(1) \geq n \} <4 $。



对每一个结点的秩都是小于父结点的。从任何一个结点到根结点的路径上，秩都是严格递增的。秩最多是 $n-1$ 。



使用势函数证明一组 $m$ 个 $MakeSet$ ，$Union$ 及 $FindSet$ 的总摊还代价为 $O(m\alpha(n))$ 。

## 第六部分 图算法



## 第22章 基本的图算法



### 图的表示



对于图 $G=(V,E)$，可以用两种标准表示方法：

- **邻接链表的组合**：一个邻接链表的头是起始结点，其他元素都是其直接相连的结点。。
- **邻接矩阵**：一个二维数组，相连置为1。

都可以表示**有向图**及**无向图**。



临界链表在表示**稀疏图**时，非常紧凑。

邻接矩阵在表示**稠密图**时，效率高。



可以存储权重，表示**权重图**。



### 广度优先搜索

最简单的图搜索算法之一，是**Prim最小生成树**算法和**Dijkstra的单源最短路径**算法的搜索思想基础。

给定**源结点**，得到所有其能到达的结点；再将这些结点视为源结点，得到下一层能到达的所有结点，删掉已经访问过的结点。可以使用不同颜色，区分是否访问过。

可以得到所有结点距离源结点的**路径边数**。

可以根据广度优先，构建一棵**广度优先树**。



### 深度优先搜索

给定**源结点**，访问其任意一个能到达的结点，将这个结点视为源结点，**递归**，直到结点没有能到达的结点或所有能到达的结点都已访问过，此时**回溯**到上一个结点，访问任意其他能到达的结点。

可以使用**栈**来实现。

根据访问关系，可以构建一个**前驱子图**，**深度优先树**。

可以同时指定多个源结点，此时多棵**深度优先树**会构成**深度优先森林**。

结点的**发现时间**和**完成时间**具有所谓的**括号化结构**（parenthesis structure），即包含所有后继结点的发现时间和完成时间，且是规整的。

两个结点的访问区间，要么是**完全分离**的，要么是**完全包含**的。



根据深度优先森林可以定义四种边：

- **树边**：访问路径上的边。
- **后向边**：边的第一个结点访问顺序在第二个结点**之后**。
- **前向边**：边的第一个结点访问顺序在第二个结点**之前**。
- **横向边**：其他的所有边，如连接两棵树的边，或同一棵树上的两个分支，即两个结点没有访问顺序上的关系。

无向图中，每条边，要么是**树边**，要么是**后向边**。深度优先，所以遇到边，不访问另一个结点的条件就是已经访问过了，所以这个边就是后向边。



### 拓扑排序

拓扑排序是图中所有结点的一种**线性次序**，满足所有边的第一个结点排在第二个结点前。

若有环路，则不存在拓扑排序。

拓扑排序将图上的所有结点在一条水平线上排开。

简单的算法为：**使用深度优先遍历，将生成的深度优先森林倒序排列。**这样就可以保证条件了，因为后生成的深度优先树的所有结点都不可能是之前树的结点的后继，但反之是可能的。

如在穿衣顺序图中，就可以按照拓扑排序的顺序进行穿戴。

一个**有向图**是**无环的**，等价于**没有后向边**。



### 强连通分量

图的一个强连通分量，是一个**最大结点集合**，满足集合内任意两个结点是可以**相互抵达**的。

一个图的强连通分量和其转置图的强连通分量相同。

分量图：将**每个强连通分量收缩成一个结点**，形成的无环有向图。分量图中的边，就是将强连通分量收缩后剩余的边。

**二次深度优先搜索**算法：首先深度优先遍历一次，记录每个结点的结束时间，之后求转置图的深度优先遍历，同一个结点内，**优先访问结束时间最大的结点**，得到的深度优先森林中的每一个树就是一个强连通分量。

思想来源：当对转置图进行深度优先遍历时，由于是转置图，边的两个结点位置互换了，实际上是**原图的逆向遍历**，这样逆向遍历的结果是**能到达其的结点**，而不是正向遍历的其能到的结点。由于**优先访问结束时间最大的结点**，根据**括号化结构**可得，其是第一次遍历时，最后一棵树的**根结点**，满足**其能到达这棵树上所有结点**，但是其他树上的结点不能到达其，所以只需要在这棵树上，**找到能到达其的结点**就可以了。







## 第23章 最小生成树

连接 $n$ 个组件的针脚，需要 $n-1$ 条线。但选择不同的连接方式，即不同的无环连通图，**生成树**，其边的总权重是不同的，求具有最小总权重的生成树问题，称为**最小生成树问题**。



### 通用生成方式

给定连通无向图 $G=（V,E)$ 和权重函数 $w:E\rightarrow R$ ，希望找到图的一棵最小生成树，使用**贪心算法**。

每个时刻生长最小生成树的一条边，并在整个策略的实施过程中，管理遵循下述**循环不变式**的边集合 $A$：

- 每次循环之前，$A$是某棵最小生成树的一个子集。

方式：

- **初始化**：初始是空集。
- **维持**：每次**选择一条不违反规则的边，即 $A$ 的安全边**。
- **终止**：所有结点都加入到集合中。

关键是**如何选择安全边**。

一些定义：

- **切割**：无向图的一个划分，有两部分。
- **横跨**：一条边的两个**端点**分别在一个**切割**的不同部分。
- **尊重**：集合 $A$ 不存在一个**切割**的**横跨**，称该切割**尊重**集合 $A$ 。
- **轻量级边**：集合中**权重最小**的横跨。

**安全边**可选择为**尊重**集合 $A$ 的任意**切割**的一条**轻量级边**。首先轻量级边一定是一个横跨，也就是连接了两部分的最小权重边，因为生成树是一个连通图，要使左右两部分连通，这条边是最经济的。

### Kruskal 算法

集合 $A$ 为森林，初始状态每一个结点为一个树，每次选择连接不同树的最小权重边，将两棵树合并为一棵。

### Prim 算法

集合 $A$ 为树，每次划分为 $(A,V-A)$ ，选择轻量级边。初始状态为权重最小边构成的树，每次将一个新结点加入到树中。



## 第24章 单源最短路径

### 最短路径问题

给定一个**带权重的图** $G=(E,V)$ ，权重函数 $w:E\rightarrow R$ 将边映射到**实数值的权重**上。一条路径的权重是路径上边的权重的和。

从结点 $v$ 到结点 $u$ 的**最短路径**为任意一条**权重最小**的路径 $p$。 $\delta(u,v)={\min\{w(p):u\leadsto v \}}$。若不存在路径，则 $\delta(u,v)=\infin$。

最短路径的几个变体：

- **单源**最短路径问题：找到从给定**源结点** $s \in V$ 到每个结点 $v \in V$ 的最短路径。

- **单目的地**最短路径问题：找到每个结点 $v$ 到给定**目的地结点** $t \in V$ 的最短路径。**将图转置**，就可以转化为单源最短路径问题。
- **单结点对**最短路径问题：找到从**给定结点** $u$ 到**给定结点** $v$ 的最短路径。实际上是**给定结点** $u$ 的**单源最短路径问题**。
- **所有结点对**最短路径问题：找到**每对结点** $u$ 和 $v$ 的最短路径。可以对每个结点进行**单源最短路径问题**，但实际上有更好方法。

最短路径的**最优子结构**：两个结点之间的一条最短路径**包含**经过结点对的一条最短路径。如果经过结点对的路径不是一条最短路径，那么将其的最短路径**替换**现有路径，会导致新路径**小于**原始结点对的最小路径，这与最小路径的定义**不符**。

**负权重**的边：权重取值可能存在**负值**，如果图不包含从**源结点** $s$ 可以达到的**权重值为负的环路**，那么对于所有结点 $v \in V$ ，最短路径权重有准确定义。否则，只需要**经过无限次负权重环路**，就可以使可以达到的结点的路径为负无穷。定义如果从 $u$ 到 $v$ 的一条路径，经过负权重环路，则 $\delta(u,v)=-\infin$。

**环路**：最短路径中，一般不包含环路，因为若环路权重为正，直接去掉可使路径权重降低；若权重为负，则最短路径权重为负无穷；若权重为0，也没有意义。

**最短路径的表示**：对每个结点，维持一个**前驱结点** $v.\pi $，指向其的前驱。通过所有结点的前驱节点，可以形成**前驱子图**，即后继结点指向前驱。

**松弛操作**：对每个结点维持一个属性 $v.d$ ，记录从源节点 $s$ 到此节点 $v$ 的最短路径权重的上界，称为**最短路径估计**。对相邻的边 $(u,v)$，进行**松弛测试**，若 $v.d > u.d + w(u,v)$，即经过 $u$ 可以达到更小的最短路径估计，那么就更新估计。松弛的含义就是，现有路径和经过其他结点路径形成一个三角，**若满足三角不等式，就是松弛的**。

最短路径和松弛操作的**性质**：

- **三角不等式**性质：对于任意边 $(u,v)$，满足 $\delta(s,v) \leq \delta(s,u) + w(u,v)$。反证法。
- **上界**性质：对于所有结点，$v.d \leq \delta(s,v)$。
- **非路径**性质：如果不存在路径，$v.d = \delta(s,v)=\infin$。
- **收敛**性质：若 $s \leadsto u \rightarrow v$是一条最短路径，则若对 $v$ 进行松弛前，有 $u.d =\delta(s,u)$，则松弛之后都有 $v.d =\delta(s,v)$ 。归纳法。
- **路径松弛**性质：如果一条最短路径上的边是依次进行松弛的，那么就会得到 $v.d =\delta(s,v)$ ，与其他路径上的松弛顺序无关。归纳法。
- **前驱子图**性质：对于所有节点 $v \in V$ ，一旦$v.d =\delta(s,v)$ ，那么其生成的前驱子图是一棵以 $s$ 为根的最短路径树，就一个树枝。



### Bellman-Ford 算法

权重可为负的单源最短路径问题。返回布尔值，明确源结点是否可以达到一个负权重回路。

````
BeelmanFord(G,w,s)
	InitializeSingleSource(G,s)
	for i=1 to |G.V|-1
		for each edge(u,v) in G.E
			Relax(u,v,w)
	for each edge(u,v) in G.E
		if v.d > u.d + w(u,v)
			return False
	return True
````

由于进行了 $|G.V|-1$ 次的遍历，且最短路径中至多含有 $|G.V|-1$ 个结点，所以**所有最短路径的排序都会出现过**，根据收敛定理，会得到最短路径。

如果有负权重环路，根据 $v.d > u.d + w(u,v)$ 可知，路径上**所有的结点的和**，与**所有结点所有边的和**，可以分别构成**不等式的两端**，但是**不满足**不等式，所以一定输出为假。

### 有向无环图的单源路径问题

由于是无环的，所以若最短路径存在，则其**唯一**。所以直接回溯，累计路径权重即可。

###  Dijkstra 算法

带权重有向图上的单源最短路径问题。

````
Dijkstra(G,w,s)
	InitializeSingleSource(G,s)
	S = []
	Q = G.V
	while Q not empty
		u = ExtractMin(Q)
		S.add(u)
		for each edge(u,v) in Adj[u]
			Relax(u,v,w)
		
````

每次从未加入的集合中找到权重最小的，加入后，更新临近结点。

### 差分约束和最短路径

**线性规划**：给定矩阵 $A:m\times n$，一个标量 $b:m \times 1$，一个标量 $c:1 \times n$，求满足 $Ax\leq b$ 条件时，优化目标函数 $\sum_{i=1}^nc_ix_i$ ，取值最大。

**差分约束系统**：线性规划矩阵 $A$ 中，每一行有且只有一个 1 和 -1。所以$Ax\leq b$ 约束条件变成了 $m$ 个设计 $n$ 个变量的**差额限制条件**，即 每个约束为$x_j - x_i \leq b_k$。

差分约束系统的**解系**：差分约束系统的解中所有元素同时加一个**常数**，仍然是这个差分约束系统的解。

**约束图**：从图论的角度理解差分约束系统。将 $A$ 看作 $n$ 个结点 $m$ 条边构成的**图的转置**。边为 $(v_i,v_j):\exist v_i-v_j \leq b_k$，$w(v_i,v_j)= b_k$，额外增加一个结点 $v_0$ ，和一组边 $(v_0,v_i)$，以便从其出发，可以达到所有结点。结点的数值是 $\delta(v_0,v_i)$。且 $x=(\delta(v_0,v_1),\delta(v_0,v_2),\cdots,\delta(v_0,v_n))$ 是一个**可行解**。如果有负值环路，则无解。