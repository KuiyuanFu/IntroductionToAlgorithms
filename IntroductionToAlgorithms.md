# IntroductionToAlgorithms

## 第一部分 基础知识



## 第1章 算法在计算中的作用

### 算法

对于给定的输入，有限时间内给出正确的输出。

- **输入**

- **输出**

- **有穷性**

- **确切性**

- **可行性**



## 第2章 算法基础



### 排序

输出为输入序列的一个特定顺序的排列。

排列的元素成为关键字，输入就是关键字的数组。



### 循环不变式

在排序过程中，每一步都保持顺序的一段序列。

- **初始化**：循环的第一次迭代之前，就是真的。
- **保持**：如果在每次循环前是真的，那么下次循环前仍是真的。
- **终止**：循环终止时，仍是真的。



### 插入排序

第 `n` 次循环时，前 `n-1` 个元素组成的序列为**循环不变式**，此次将第 `n` 个按顺序**插入**到前 `n-1` 个中。

````c++
InsertionSort(A)
    for j = 2 to A.length
    	key = A[j]
        // 插入，通过移位的方式执行。
        i=j-1
        while i >0 and A[i]>key
            A[i+1]=A[i]
            i = i-1
        A[i+1] =key
````



### 分治法

 分治法通常可以使用递归结构，三个步骤：

- **分解**：将原问题分解为若干子问题，这些子问题是原问题的规模较小的实例。
- **解决**：对子问题递归求解，子问题较小时，直接求解。
- **合并**：将子问题的解组合成原问题的解。



### 归并排序

分两段，合并，两倍空间。

````c++
Merge(A,p,q,r)
    n1 = q-p+1
    n2 = r-q
    let L[1..n1+1] and R[1..n_2+1] be new arrays
    for i=1 to n1
        L[i]=A[p+i-1]
    for j=1 to n2
        R[j]=A[p+j-1]
    L[n1+1] = +infin
    R[n2+1] = +infin
    i =1 
    j =1
    for k=p to r
        if L[i] <= R[j]
            A[k]= L[i]
            i+=1
        else
            A[k]= R[j]
            j+=1
            
MergeSort(A,p,r)
    if p <r
        q = (p+r)/2
        MergeSort(A,p,q)
        MergeSort(A,q+1,r)
        Merge(A,p,q,r)
            
````







## 第3章 函数的增长

### 渐进效率

当输入规模足够大，使得只与运行时间的增长量级有关，即算法的渐进效率，忽略较小的增长量级与常数项。

- $\Theta(g(x)) = \{f(x)|\exist c_1,c_2,n_0 ,\forall n\geq n_0,0\leq c_1g(n)\leq f(n) \leq c_2g(n)\}$  ，渐进紧确界，就是说 $f(x)$ 被 $g(x)$ 夹在了中间。
- $O(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0\leq  f(n) \leq cg(n)\}$  ，渐进上界，就是说 $f(x)$ 在 $g(x)$ 下面。 $g(x)$ 可能同阶，也可能高阶。
- $\Omega(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0 \leq cg(n)\leq  f(n)\}$  ，渐进下界，就是说 $f(x)$ 在 $g(x)$ 上面。 $g(x)$ 可能同阶，也可能低阶。
- $o(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0\leq  f(n) < cg(n)\}$  ，非渐进紧确的上界，就是说 $f(x)$ 在 $g(x)$ 下面。 $g(x)$ 高阶。
- $\omega(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0 \leq cg(n)<  f(n)\}$  ，非渐进紧确的下界，就是说 $f(x)$ 在 $g(x)$ 上面。 $g(x)$ 低阶。



## 第4章 分治策略

 ### 分治法

分治法通常可以使用递归结构，三个步骤：

- **分解**：将原问题分解为若干子问题，这些子问题是原问题的规模较小的实例。
- **解决**：对子问题递归求解，子问题较小时，直接求解。
- **合并**：将子问题的解组合成原问题的解。

在解决问题这步骤中，如果子问题足够大，需要递归求解时，称之为**递归情况**；而子问题足够小，可以直接求解，叫做**基本情况**。



关键点是如何分解成**更小规模**的相同问题。



###  递归式

**递归式通过**更小的输入上的**函数值**来描述一个**函数**。
$$
T(n)=\cases{ \Theta(1) & n=1 \\a T(n/b) + \Theta(n) & n>1 }
$$


### 求解递归式的方法

- **代入法**：猜测一个界，之后用数学归纳法证明其正确性。
- **递归树法**：将递归式转化为一棵树，其节点表示不同层次的递归调用产生的代价。然后采用边界和技术求解递归式。
- **主方法**：解决均分递归式，最常用。



### 最大子数组问题

寻找数组 $A$ 的一个**最大**的**非空连续子数组**。

买卖一次股票以获得最大收益时，将每天的**价格**，**变换**成每天的**涨跌值**，就将问题转化为了最大子数组问题。



递归主要思想是，最大子数组左右边界只有三种情况：

- 全在左面：递归调用
- 全在右面：递归调用
- 跨越中线：从中间向两端找最大值，合并。

````c++
FindMaxCrossingSubarray(A,low,mid,high)
	leftSum = -infin
    sum =0
    for i = min downto low
        sum = sum+A[i]
        if sum>leftSum
           	leftSum = sum
            maxLeft = i
    rightSum = -infin
    sum =0
    for j = mid+1 to high
        sum = sum+A[j]
        if sum>rightSum
           	rightSum = sum
            maxRight = j
    return (maxLeft,maxRight,leftSum+rightSum)
            
FindMaximumSubarray(A,low,high)
    if high == low
        return (low,high,A[low])
    (leftLow,leftHigh,leftSum)=FindMaximumSubarray(A,low,mid)
    (rightLow,rightHigh,rightSum)=FindMaximumSubarray(A,mid+1,high)
    (crossLow,crossHigh,crossSum)=FindMaxCrossingSubarray(A,low,mid,high)
    if leftSum>=rightSum and leftSum >=crossSum
        return (leftLow,leftHigh,leftSum)
    elseif  rightSum>=leftSum and rightSum >=crossSum
    	return (rightLow,rightHigh,rightSum)
    elseif  crossSum>=leftSum and crossSum >=rightSum
    	return (crossLow,crossHigh,crossSum)
        
        
````



### 矩阵乘法 Strassen算法

普通矩阵乘法，使用逐行逐列相乘求和，$O(n^3)$。

普通分治思想，均分四块，分块矩阵乘法，$O(n^3)$。

Strassen算法，均分四块，之后先算10个子矩阵的和，之后再算4个子矩阵与10个和矩阵的7个矩阵乘，之后再把7个矩阵积组合成分块矩阵的正常结果。使用了7次矩阵乘法，而不是普通分块的8次，$O(n^{\lg7})$。

### 带入法求渐进复杂度

根据之前类似结构的算法的渐进效率，估计此算法可能的渐进效率，之后验证。

- 猜测解的形式
- 数学归纳法解出常数，证明正确性。

要选择合适的 $n_0$ ，因为在边界时，很容易出问题。

可以先猜一个比较大的上界，再慢慢缩小。



较强的上界可能会比更较的上界更容易用数学归纳法证明。如 $T(n)= 2T(n/2)+1$ 得到 $T(n)\leq cn$ :

若假设 $T(n)\leq cn$ ，则 $T(n)= 2T(n/2)+1 \leq 2cn/2 +1 = cn+1$ 。无法证明。

若假设 $T(n)\leq cn-d$ ，则 $T(n)= 2T(n/2)+1 \leq 2(cn/2 -d ) +1 = cn-2d+1\leq cn-d$ 。证明。



在证明时，需要证出与归纳假设严格一样的形式，不能合并 $c$ 与常数。如错误证明$T(n)= 2T(n/2)$ 得到 $T(n)\leq cn$ ：$T(n) \leq 2(c[n/2])+n \leq cn +n = O(n)$。

原因在于证出的是$T(n)\leq (c +1 )n$ ，虽然同阶，但不等。实际为$T(n)\leq n\lg(n)$。



可以适当变换变量形式，指数对数变换，方便证明。$T(n) = 2T([\sqrt{n}])+\lg (n)$， $m=\lg n$ ，$S(m)=2S(m/2)+m$ ，$S(m)=O(m \lg m)$， $T(n)=T(2^m)=S(m)=O(m\lg m) = O(\lg n \lg\lg n))$。

### 递归树求渐进复杂度

首先将递归结构展开成树的形式，之后计算每层的复杂度，再求和。用来估计最可能的渐进复杂度，之后用代入法证明。

### 主方法求渐进复杂度

用以求解 $T(n)=aT(n/b)+f(n)$ 型的递归式：



- 若 $f(n)=O(n^{\log_b{a-\epsilon}})$，则 $T(n)=\Theta(n^{\log_b{a}})$
- 若 $f(n)=\Theta(n^{\log_b{a}})$，则 $T(n)=\Theta(n^{\log_b{a}}\lg n)$
- 若 $f(n)=\Omega(n^{\log_b{a+\epsilon}})$，则 $T(n)=\Theta(f(n))$ 

直觉上就是比较递归部分与函数部分的大小。不等则为大的那个；相等则递归树变宽，乘 $\lg n$ 系数。



## 第5章 概率分析和随机算法





### 随机算法

一个算法的行为不仅由输入决定，还使用随机数生成器生成的随机序列决定，就称指为随机算法。

很多随机算法通过对输入进行随机排列。



### 概率分析

寻找一个随机算法的平均情况运行时间，也就是期望。



### 指示器随机变量

给定一个样本空间 $S$ ，一个事件 $A$ ，那么对应的指示器随机变量就是 $I\{A\} = \cases {1&true\\0 &false}$ 。



### 雇佣问题

面试，立即决定是否录用，选择最好的，计算录用次数。面试者的能力随机，是最简单的随机形式。

录用面试者次数期望是 $\lg n$ 。每次面试的面试者比前面所有人强的概率是 $p(i)=1/i$ ，所以期望 $E(X) = \sum_{i=1}^{n}(1/i) = \lg n$。

### 生日悖论

一群人中存在同一天生日的两人的概率大于一半需要最少多少人。$n$天，$k$人， 每个人不与前人重复的概率 $p(i)=(n-(i-1))/n$ 。$p(X) = \prod_{i=1}^{n}(n-(i-1))/n \leq e^{-k(k-1)/2n} $。

### 球与箱子

$b$ 个箱子，每次投球必中一个箱子。

问多少个求落在指定的箱子内。$E(X) = n/b$。

问所有箱子都有球，投掷的次数的期望，第 $i$ 个箱子进入的概率为 $p(i)=(1-(i-1)/b)$ ，就是扔到已有球箱子概率的补； $E(X) = \sum_{i=1}^{b}1/(1-(i-1)/b) = b\ln b$。



### 特征序列

抛硬币连续正面的特征序列的长度期望是 $\Theta(\lg n)$。利用不等式求上界。       

$p(i) = 1/2^i$ ， 对于 $k=2\lg n$ ，$p(k)=1/2^{2\lg n} = 1/n^2 $ 。也就是说，对于目标特征序列长度为 $2\lg n$ 的概率为 $ 1/n^2 $ ，但是整个长度为 $n$ 的情况下，一共有 $n- 2\lg n$ 个位置有可能达到这个长度，即长度为 $2\lg n$ 的概率为 $(n- 2\lg n    )*1/n^2  = 1/n$  。所以总期望为 $E(X) = \sum_{i=1}^{n}(1/i) = \lg n$ 。



### 在线雇佣问题

求在给定选中最好的员工的概率下，选择的策略。前 $k$ 个中，记录最好的人，之后的 $n-k$ 个中，只要遇到比前 $k$ 个最好的更好的人，就选择这个，求 $k$ 的值。

首先最好的在前 $k$ 个中一定选不到，而在后  $n-k$ 个中时，需要排在其前面的都小于前 $k$ 个最好的，概率为 $p(i) = (k)/(i-1)$ ，所以在 指定 $k$ 的情况下，选到最好的概率为 $E(X) = \sum_{i=k+1}^{n} (k)/(i-1) \leq k/n (\ln (n-1) - \ln (k-1)) $



## 第二部分 排序和顺序统计量



| 算法 |       最坏        |       平均        |
| :--: | :---------------: | :---------------: |
| 插入 |   $\Theta(n^2)$   |   $\Theta(n^2)$   |
| 归并 | $\Theta(n\lg n)$  | $\Theta(n\lg n)$  |
|  堆  | $\Theta(n\lg n)$  |                   |
| 快速 |   $\Theta(n^2)$   | $\Theta(n\lg n)$  |
| 计数 |  $\Theta(k+ n)$   |  $\Theta(k+ n)$   |
| 基数 | $\Theta(d(k+ n))$ | $\Theta(d(k+ n))$ |
|  桶  |   $\Theta(n^2)$   |    $\Theta(n)$    |



## 第6章 堆排序

### 堆

近似的完全二叉树，可以使用数组、节点等物理结构。通常使用数组，方便计算。

最大堆就是最大值在堆顶。节点元素大于子节点元素。

原址算法。

可以实现优先队列。

### 从上至下维护

若节点的所有子节点都是堆，只有此节点元素是新加入的，需要从上到下维护，使其成堆。

方法是：比较节点元素与子节点元素，若大于所有子节点元素，无需操作。否者将最大元素与此节点元素互换，之后继续维护互换后的子节点。

### 从下至上维护

若节点的父节点都是堆，只有此节点元素是新加入的，需要从下到上维护，使其成堆。

方法是：比较节点元素与父节点元素，若父节点元素大于此节点元素，无需操作。否者将父节点元素与此节点元素互换，之后继续维护互换后的父节点。

### 建堆

使用从上至下维护的方法，可以从底向上的建立一个堆；

### 移除

去掉堆顶，移动最后一个到堆顶，从上至下维护。

### 添加

添加最后一个，从下至上维护。





## 第7章 快速排序

### 快速排序

原址排序。最坏情况很差，但平均很好，实际中很好。



- 分解：选择一个数，将数组分成大于其与小于等于其的两组。
- 解决：递归调用，或规模很小时，直接求解。
- 合并：原址，不需要操作。



````c++
Partition(A,p,r)
    x= A[r]
    i=p-1
    for j = p to r-1
        if A[j]<x
            i++
            exchange A[i] with A[j]
    exchange A[i+1] with A[r]       
    return i+1
QuickSort(A,p,r)    
    if p<r
        q = Partition(A,p,r)
        QuickSort(A,q+1,r) 
        QuickSort(A,p,q-1) 
        
````



循环不变式

- 初始化：空，成立
- 保持：每次交换，交换后，左边的都是比目标值小，而右边的时比目标值大的。成立。
- 终止：必然成立。



最坏情况为选择的主元素是范围内最值，退化为冒泡排序，因为每次只选中了最值，而问题规模只减少1。

最好情况为选择的主元素是范围内中位数，类似归并排序。

## 第8章 线性时间排序

### 排序算法的下界

比较排序，最快$\Theta(n\lg n)$，好的方法也就是在常数项上优于归并和堆。

基于运算的排序，可以达到线性时间。

### 决策树模型

一棵完全二叉树，枝干节点是输入序列两个位置比较运算操作，子树是对应结果的分支，叶子节点存储结果。

每一个比较排序都可以生成一棵决策树，共有 $n!$ 个排列的叶子节点。

最坏条件下需要比较$\Theta(n\lg n)$ 次。

### 计数排序

对于每个输入元素，确定小于其的元素个数，这样可以直接排序了。若 $k=O(n)$ ，则以空间换时间。

其实可以不统计个数，直接按照是否有值来进行排序。

````c++
CountingSort(A,B,k)
    let C[0..k]
    for i =0 to k
        C[i] =0
    // 看哪一位上有值
    for j=1 to A.length
        C[A[j]]=C[A[j]]+1
    // 统计小于其的元素个数
    for i =0 to k
        c[i]=c[i]+c[i-1]
    for j =A.length downto 1
        // 输出数组中A[j]元素个数位置
        B[C[A[j]]] =A[j]
        C[A[j]]=C[A[j]]-1
      
````

###  基数排序

特定使用场景，卡片机。$n$ 个卡片，表示多少个数字；每个卡片 $d$ 行，表示多少位；每行 $10$ 个空，表示多少进制。

从地位向高位排列，每次将此位上大的放在前面。

### 桶排序

假设输入为 $[0,1)$ 的数，之后将元素与输入序列长度相乘取整，得到元素桶的索引，这样把每个元素分到了对应的桶中，桶的顺序就是元素原来的顺序，再在桶中排序，降低问题规模。

最坏情况为所有元素分到了一个桶中，退化成了插入排序。

最好情况为所有元素都不在一个桶中，进化成了基数排序。但又省了空间。

平均情况，$n_i$ 表示第 $i $ 个桶中元素个数，$E(X) = \Theta(n) + \sum_{i=1}^n O( n_i^2)$，可以断言 $E(  n_i^2)=2-1/n$，所以 $E(T(n))=\Theta(n)$。

证 $E(  n_i^2)=2-1/n$：

设 $X_{ij}=I\{A[j]\in \mathrm{Bucket}[i]\}$ ，则

$n_i=\sum_{j=1}^nX_{ij}$ ，展开得到$E(n_i^2)=E(\sum_{j=1}^nX_{ij}^2+\sum_{j=1}^n\sum_{k=1,k\neq j}^nX_{ij}X_{ik})$  ，分别求期望，$E(X_{ij}^2)=1/n$   ，$E(X_{ij}X_{ik})=1/n^2$  ，合并 $E(n_i^2)=E(\sum_{j=1}^nX_{ij}^2+\sum_{j=1}^n\sum_{k=1,k\neq j}^nX_{ij}X_{ik})=n*1/n+n(n-1)*1/n^2=2-1/n$。

````c++
BucketSort(A)
    n=A.length
    let B[0..n-1]
    for i =0 to n-1
        B[i]= list
    // 分在不同的桶中
    for i =1 to n
        B[i].add(nA[i])
    for i =0 to n-1
        InsertingSort(B[i])
    concatenate B[0..n-1]
````





## 第章



````c++

````



