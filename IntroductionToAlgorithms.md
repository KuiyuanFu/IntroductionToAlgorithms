# IntroductionToAlgorithms

## 第一部分 基础知识



## 第1章 算法在计算中的作用

### 算法

对于给定的输入，有限时间内给出正确的输出。

- **输入**

- **输出**

- **有穷性**

- **确切性**

- **可行性**



## 第2章 算法基础



### 排序

输出为输入序列的一个特定顺序的排列。

排列的元素成为关键字，输入就是关键字的数组。



### 循环不变式

在排序过程中，每一步都保持顺序的一段序列。

- **初始化**：循环的第一次迭代之前，就是真的。
- **保持**：如果在每次循环前是真的，那么下次循环前仍是真的。
- **终止**：循环终止时，仍是真的。



### 插入排序

第 `n` 次循环时，前 `n-1` 个元素组成的序列为**循环不变式**，此次将第 `n` 个按顺序**插入**到前 `n-1` 个中。

````c++
InsertionSort(A)
    for j = 2 to A.length
    	key = A[j]
        // 插入，通过移位的方式执行。
        i=j-1
        while i >0 and A[i]>key
            A[i+1]=A[i]
            i = i-1
        A[i+1] =key
````



### 分治法

 分治法通常可以使用递归结构，三个步骤：

- **分解**：将原问题分解为若干子问题，这些子问题是原问题的规模较小的实例。
- **解决**：对子问题递归求解，子问题较小时，直接求解。
- **合并**：将子问题的解组合成原问题的解。



### 归并排序

分两段，合并，两倍空间。

````c++
Merge(A,p,q,r)
    n1 = q-p+1
    n2 = r-q
    let L[1..n1+1] and R[1..n_2+1] be new arrays
    for i=1 to n1
        L[i]=A[p+i-1]
    for j=1 to n2
        R[j]=A[p+j-1]
    L[n1+1] = +infin
    R[n2+1] = +infin
    i =1 
    j =1
    for k=p to r
        if L[i] <= R[j]
            A[k]= L[i]
            i+=1
        else
            A[k]= R[j]
            j+=1
            
MergeSort(A,p,r)
    if p <r
        q = (p+r)/2
        MergeSort(A,p,q)
        MergeSort(A,q+1,r)
        Merge(A,p,q,r)
            
````







## 第3章 函数的增长

### 渐进效率

当输入规模足够大，使得只与运行时间的增长量级有关，即算法的渐进效率，忽略较小的增长量级与常数项。

- $\Theta(g(x)) = \{f(x)|\exist c_1,c_2,n_0 ,\forall n\geq n_0,0\leq c_1g(n)\leq f(n) \leq c_2g(n)\}$  ，渐进紧确界，就是说 $f(x)$ 被 $g(x)$ 夹在了中间。
- $O(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0\leq  f(n) \leq cg(n)\}$  ，渐进上界，就是说 $f(x)$ 在 $g(x)$ 下面。 $g(x)$ 可能同阶，也可能高阶。
- $\Omega(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0 \leq cg(n)\leq  f(n)\}$  ，渐进下界，就是说 $f(x)$ 在 $g(x)$ 上面。 $g(x)$ 可能同阶，也可能低阶。
- $o(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0\leq  f(n) < cg(n)\}$  ，非渐进紧确的上界，就是说 $f(x)$ 在 $g(x)$ 下面。 $g(x)$ 高阶。
- $\omega(g(x)) = \{f(x)|\exist c,n_0 ,\forall n\geq n_0,0 \leq cg(n)<  f(n)\}$  ，非渐进紧确的下界，就是说 $f(x)$ 在 $g(x)$ 上面。 $g(x)$ 低阶。



## 第4章 分治策略

 ### 分治法

分治法通常可以使用递归结构，三个步骤：

- **分解**：将原问题分解为若干子问题，这些子问题是原问题的规模较小的实例。
- **解决**：对子问题递归求解，子问题较小时，直接求解。
- **合并**：将子问题的解组合成原问题的解。

在解决问题这步骤中，如果子问题足够大，需要递归求解时，称之为**递归情况**；而子问题足够小，可以直接求解，叫做**基本情况**。



关键点是如何分解成**更小规模**的相同问题。



###  递归式

**递归式通过**更小的输入上的**函数值**来描述一个**函数**。
$$
T(n)=\cases{ \Theta(1) & n=1 \\a T(n/b) + \Theta(n) & n>1 }
$$


### 求解递归式的方法

- **代入法**：猜测一个界，之后用数学归纳法证明其正确性。
- **递归树法**：将递归式转化为一棵树，其节点表示不同层次的递归调用产生的代价。然后采用边界和技术求解递归式。
- **主方法**：解决均分递归式，最常用。



### 最大子数组问题

寻找数组 $A$ 的一个**最大**的**非空连续子数组**。

买卖一次股票以获得最大收益时，将每天的**价格**，**变换**成每天的**涨跌值**，就将问题转化为了最大子数组问题。



递归主要思想是，最大子数组左右边界只有三种情况：

- 全在左面：递归调用
- 全在右面：递归调用
- 跨越中线：从中间向两端找最大值，合并。

````c++
FindMaxCrossingSubarray(A,low,mid,high)
	leftSum = -infin
    sum =0
    for i = min downto low
        sum = sum+A[i]
        if sum>leftSum
           	leftSum = sum
            maxLeft = i
    rightSum = -infin
    sum =0
    for j = mid+1 to high
        sum = sum+A[j]
        if sum>rightSum
           	rightSum = sum
            maxRight = j
    return (maxLeft,maxRight,leftSum+rightSum)
            
FindMaximumSubarray(A,low,high)
    if high == low
        return (low,high,A[low])
    (leftLow,leftHigh,leftSum)=FindMaximumSubarray(A,low,mid)
    (rightLow,rightHigh,rightSum)=FindMaximumSubarray(A,mid+1,high)
    (crossLow,crossHigh,crossSum)=FindMaxCrossingSubarray(A,low,mid,high)
    if leftSum>=rightSum and leftSum >=crossSum
        return (leftLow,leftHigh,leftSum)
    elseif  rightSum>=leftSum and rightSum >=crossSum
    	return (rightLow,rightHigh,rightSum)
    elseif  crossSum>=leftSum and crossSum >=rightSum
    	return (crossLow,crossHigh,crossSum)
        
        
````



### 矩阵乘法 Strassen算法

普通矩阵乘法，使用逐行逐列相乘求和，$O(n^3)$。

普通分治思想，均分四块，分块矩阵乘法，$O(n^3)$。

Strassen算法，均分四块，之后先算10个子矩阵的和，之后再算4个子矩阵与10个和矩阵的7个矩阵乘，之后再把7个矩阵积组合成分块矩阵的正常结果。使用了7次矩阵乘法，而不是普通分块的8次，$O(n^{\lg7})$。

### 带入法求渐进复杂度

根据之前类似结构的算法的渐进效率，估计此算法可能的渐进效率，之后验证。

- 猜测解的形式
- 数学归纳法解出常数，证明正确性。

要选择合适的 $n_0$ ，因为在边界时，很容易出问题。

可以先猜一个比较大的上界，再慢慢缩小。



较强的上界可能会比更较的上界更容易用数学归纳法证明。如 $T(n)= 2T(n/2)+1$ 得到 $T(n)\leq cn$ :

若假设 $T(n)\leq cn$ ，则 $T(n)= 2T(n/2)+1 \leq 2cn/2 +1 = cn+1$ 。无法证明。

若假设 $T(n)\leq cn-d$ ，则 $T(n)= 2T(n/2)+1 \leq 2(cn/2 -d ) +1 = cn-2d+1\leq cn-d$ 。证明。



在证明时，需要证出与归纳假设严格一样的形式，不能合并 $c$ 与常数。如错误证明$T(n)= 2T(n/2)$ 得到 $T(n)\leq cn$ ：$T(n) \leq 2(c[n/2])+n \leq cn +n = O(n)$。

原因在于证出的是$T(n)\leq (c +1 )n$ ，虽然同阶，但不等。实际为$T(n)\leq n\lg(n)$。



可以适当变换变量形式，指数对数变换，方便证明。$T(n) = 2T([\sqrt{n}])+\lg (n)$， $m=\lg n$ ，$S(m)=2S(m/2)+m$ ，$S(m)=O(m \lg m)$， $T(n)=T(2^m)=S(m)=O(m\lg m) = O(\lg n \lg\lg n))$。

### 递归树求渐进复杂度

首先将递归结构展开成树的形式，之后计算每层的复杂度，再求和。用来估计最可能的渐进复杂度，之后用代入法证明。

### 主方法求渐进复杂度

用以求解 $T(n)=aT(n/b)+f(n)$ 型的递归式：



- 若 $f(n)=O(n^{\log_b{a-\epsilon}})$，则 $T(n)=\Theta(n^{\log_b{a}})$
- 若 $f(n)=\Theta(n^{\log_b{a}})$，则 $T(n)=\Theta(n^{\log_b{a}}\lg n)$
- 若 $f(n)=\Omega(n^{\log_b{a+\epsilon}})$，则 $T(n)=\Theta(f(n))$ 

直觉上就是比较递归部分与函数部分的大小。不等则为大的那个；相等则递归树变宽，乘 $\lg n$ 系数。



## 第5章 概率分析和随机算法





### 随机算法

一个算法的行为不仅由输入决定，还使用随机数生成器生成的随机序列决定，就称指为随机算法。

很多随机算法通过对输入进行随机排列。



### 概率分析

寻找一个随机算法的平均情况运行时间，也就是期望。



### 指示器随机变量

给定一个样本空间 $S$ ，一个事件 $A$ ，那么对应的指示器随机变量就是 $I\{A\} = \cases {1&true\\0 &false}$ 。



### 雇佣问题

面试，立即决定是否录用，选择最好的，计算录用次数。面试者的能力随机，是最简单的随机形式。

录用面试者次数期望是 $\lg n$ 。每次面试的面试者比前面所有人强的概率是 $p(i)=1/i$ ，所以期望 $E(X) = \sum_{i=1}^{n}(1/i) = \lg n$。

### 生日悖论

一群人中存在同一天生日的两人的概率大于一半需要最少多少人。$n$天，$k$人， 每个人不与前人重复的概率 $p(i)=(n-(i-1))/n$ 。$p(X) = \prod_{i=1}^{n}(n-(i-1))/n \leq e^{-k(k-1)/2n} $。

### 球与箱子

$b$ 个箱子，每次投球必中一个箱子。

问多少个求落在指定的箱子内。$E(X) = n/b$。

问所有箱子都有球，投掷的次数的期望，第 $i$ 个箱子进入的概率为 $p(i)=(1-(i-1)/b)$ ，就是扔到已有球箱子概率的补； $E(X) = \sum_{i=1}^{b}1/(1-(i-1)/b) = b\ln b$。



### 特征序列

抛硬币连续正面的特征序列的长度期望是 $\Theta(\lg n)$。利用不等式求上界。       

$p(i) = 1/2^i$ ， 对于 $k=2\lg n$ ，$p(k)=1/2^{2\lg n} = 1/n^2 $ 。也就是说，对于目标特征序列长度为 $2\lg n$ 的概率为 $ 1/n^2 $ ，但是整个长度为 $n$ 的情况下，一共有 $n- 2\lg n$ 个位置有可能达到这个长度，即长度为 $2\lg n$ 的概率为 $(n- 2\lg n    )*1/n^2  = 1/n$  。所以总期望为 $E(X) = \sum_{i=1}^{n}(1/i) = \lg n$ 。



### 在线雇佣问题

求在给定选中最好的员工的概率下，选择的策略。前 $k$ 个中，记录最好的人，之后的 $n-k$ 个中，只要遇到比前 $k$ 个最好的更好的人，就选择这个，求 $k$ 的值。

首先最好的在前 $k$ 个中一定选不到，而在后  $n-k$ 个中时，需要排在其前面的都小于前 $k$ 个最好的，概率为 $p(i) = (k)/(i-1)$ ，所以在 指定 $k$ 的情况下，选到最好的概率为 $E(X) = \sum_{i=k+1}^{n} (k)/(i-1) \leq k/n (\ln (n-1) - \ln (k-1)) $



## 第二部分 排序和顺序统计量



| 算法 |       最坏        |       平均        |
| :--: | :---------------: | :---------------: |
| 插入 |   $\Theta(n^2)$   |   $\Theta(n^2)$   |
| 归并 | $\Theta(n\lg n)$  | $\Theta(n\lg n)$  |
|  堆  | $\Theta(n\lg n)$  |                   |
| 快速 |   $\Theta(n^2)$   | $\Theta(n\lg n)$  |
| 计数 |  $\Theta(k+ n)$   |  $\Theta(k+ n)$   |
| 基数 | $\Theta(d(k+ n))$ | $\Theta(d(k+ n))$ |
|  桶  |   $\Theta(n^2)$   |    $\Theta(n)$    |



## 第6章 堆排序

### 堆

近似的完全二叉树，可以使用数组、节点等物理结构。通常使用数组，方便计算。

最大堆就是最大值在堆顶。节点元素大于子节点元素。

原址算法。

可以实现优先队列。

### 从上至下维护

若节点的所有子节点都是堆，只有此节点元素是新加入的，需要从上到下维护，使其成堆。

方法是：比较节点元素与子节点元素，若大于所有子节点元素，无需操作。否者将最大元素与此节点元素互换，之后继续维护互换后的子节点。

### 从下至上维护

若节点的父节点都是堆，只有此节点元素是新加入的，需要从下到上维护，使其成堆。

方法是：比较节点元素与父节点元素，若父节点元素大于此节点元素，无需操作。否者将父节点元素与此节点元素互换，之后继续维护互换后的父节点。

### 建堆

使用从上至下维护的方法，可以从底向上的建立一个堆；

### 移除

去掉堆顶，移动最后一个到堆顶，从上至下维护。

### 添加

添加最后一个，从下至上维护。





## 第7章 快速排序

### 快速排序

原址排序。最坏情况很差，但平均很好，实际中很好。



- 分解：选择一个数，将数组分成大于其与小于等于其的两组。
- 解决：递归调用，或规模很小时，直接求解。
- 合并：原址，不需要操作。



````c++
Partition(A,p,r)
    x= A[r]
    i=p-1
    for j = p to r-1
        if A[j]<x
            i++
            exchange A[i] with A[j]
    exchange A[i+1] with A[r]       
    return i+1
QuickSort(A,p,r)    
    if p<r
        q = Partition(A,p,r)
        QuickSort(A,q+1,r) 
        QuickSort(A,p,q-1) 
        
````



循环不变式

- 初始化：空，成立
- 保持：每次交换，交换后，左边的都是比目标值小，而右边的时比目标值大的。成立。
- 终止：必然成立。



最坏情况为选择的主元素是范围内最值，退化为冒泡排序，因为每次只选中了最值，而问题规模只减少1。

最好情况为选择的主元素是范围内中位数，类似归并排序。

## 第8章 线性时间排序

### 排序算法的下界

比较排序，最快$\Theta(n\lg n)$，好的方法也就是在常数项上优于归并和堆。

基于运算的排序，可以达到线性时间。

### 决策树模型

一棵完全二叉树，枝干节点是输入序列两个位置比较运算操作，子树是对应结果的分支，叶子节点存储结果。

每一个比较排序都可以生成一棵决策树，共有 $n!$ 个排列的叶子节点。

最坏条件下需要比较$\Theta(n\lg n)$ 次。

### 计数排序

对于每个输入元素，确定小于其的元素个数，这样可以直接排序了。若 $k=O(n)$ ，则以空间换时间。

其实可以不统计个数，直接按照是否有值来进行排序。

````c++
CountingSort(A,B,k)
    let C[0..k]
    for i =0 to k
        C[i] =0
    // 看哪一位上有值
    for j=1 to A.length
        C[A[j]]=C[A[j]]+1
    // 统计小于其的元素个数
    for i =0 to k
        c[i]=c[i]+c[i-1]
    for j =A.length downto 1
        // 输出数组中A[j]元素个数位置
        B[C[A[j]]] =A[j]
        C[A[j]]=C[A[j]]-1
      
````

###  基数排序

特定使用场景，卡片机。$n$ 个卡片，表示多少个数字；每个卡片 $d$ 行，表示多少位；每行 $10$ 个空，表示多少进制。

从地位向高位排列，每次将此位上大的放在前面。

### 桶排序

假设输入为 $[0,1)$ 的数，之后将元素与输入序列长度相乘取整，得到元素桶的索引，这样把每个元素分到了对应的桶中，桶的顺序就是元素原来的顺序，再在桶中排序，降低问题规模。

最坏情况为所有元素分到了一个桶中，退化成了插入排序。

最好情况为所有元素都不在一个桶中，进化成了基数排序。但又省了空间。

平均情况，$n_i$ 表示第 $i $ 个桶中元素个数，$E(X) = \Theta(n) + \sum_{i=1}^n O( n_i^2)$，可以断言 $E(  n_i^2)=2-1/n$，所以 $E(T(n))=\Theta(n)$。

证 $E(  n_i^2)=2-1/n$：

设 $X_{ij}=I\{A[j]\in \mathrm{Bucket}[i]\}$ ，则

$n_i=\sum_{j=1}^nX_{ij}$ ，展开得到$E(n_i^2)=E(\sum_{j=1}^nX_{ij}^2+\sum_{j=1}^n\sum_{k=1,k\neq j}^nX_{ij}X_{ik})$  ，分别求期望，$E(X_{ij}^2)=1/n$   ，$E(X_{ij}X_{ik})=1/n^2$  ，合并 $E(n_i^2)=E(\sum_{j=1}^nX_{ij}^2+\sum_{j=1}^n\sum_{k=1,k\neq j}^nX_{ij}X_{ik})=n*1/n+n(n-1)*1/n^2=2-1/n$。

````c++
BucketSort(A)
    n=A.length
    let B[0..n-1]
    for i =0 to n-1
        B[i]= list
    // 分在不同的桶中
    for i =1 to n
        B[i].add(nA[i])
    for i =0 to n-1
        InsertingSort(B[i])
    concatenate B[0..n-1]
````



## 第9章 中位数与顺序统计量



### 顺序统计量

第 $i$ 个顺序统计量，就是该集合中第 $i$ 小的元素。

### 最值

在一个 $n$ 元素集合中，多少次比较才能找到最值。上界是 $n-1$，下界也是 $n-1$。

那么同时找到最大值与最小值需要多少次比较，直观上界是 $2n-2$，实际可以是$3[n/2]$。方法是记录前两个值为最值，之后成对比较，之后较小的与最小值比较，较大的与最大值比较。

### 线性时间选择算法

利用快排思想，每次将输入分为两部分，看两部分的元素数量与目标位置的关系，确定目标在哪部分中，递归。

最坏情况是每次只剔除了区分元素，退还成了选择排序。

平均情况是，太复杂。大意是，主元的位置是随机的，并假设每次目标都在数量多的区域中，之后求期望。

````c++
//返回数组A p-r索引中，第i小的元素
RandomizedSelect(A,p,r,i)
    if p==r
        return A[p]
    // 快排中的分区域，返回的是选中的区分元素的下标
    q = RandomizedPartition(A,p,r) 
    k = q-p+1
    // 恰巧区分元素是第i小的
    if i== k
        return A[q]
    // 左面    
    else if i<K
        return RandomizedSelect(A,p,q-1,i)
    // 右面       
    else
        return RandomizedSelect(A,q+1,r,i-k)
        
````

### 最坏情况为线性时间的选择算法



- 划分为 $n/5$ 组
- 找每一组的中位数
- 对这些中位数递归调用求中位数
- 按照找到的中位数对原输入进行划分
- 根据区域数量进行递归调用



因为每次划分的依据都是中位数的中位数，所以至少有 $((n/5 )/2-2)*3 = 3/10 *n+6$ 个数据被剔除。

先猜，后数学归纳法验证。

$T(n) = T(n/5 ) + T(7n/10+6) +O(n)$，设其为线性， $T(n)\leq cn$ ，则可以推出 $T(n)\leq cn/5+c+7cn/10 +6c +an =cn +(-cn/10 +7c+an)$ ，只要满足  $c\geq 10a(n/(n-70))$ 即可成立。



## 第三部分 数据结构

动态集合的元素

动态集合上的操作



## 第10章 基本数据结构



### 栈

后进先出

栈下溢：在空栈中取出元素

栈上溢：向满的栈中添加元素



### 队列

先进先出

- 普通队列。

- 循环队列。

### 链表

线性排列

链表的顺序是由节点中的指针确定的，而不是物理位置。可以使用数组，用索引来模拟链表指针。

- 单向链表
- 双向链表
- 循环链表
- 非循环链表



### 有根树

可以使用数组来模拟树，特别是二叉树，可以很好的模拟，不用使用除元素外的额外引用空间。

而多分支的结构需要额外索引。



## 第11章 散列表



### 直接寻址表

从关键字全域中直接找到数组中的索引，数组中存储链表指针，之后链表存储卫星数据。每个全域中的元素对应一个数组中的索引，当全域很大时，数组也很大。

实际上就是一个单纯的数组，索引。

### 散列表

实现字典的一种有效数据结构。最坏 $\Theta(n)$ ，平均实际 $O(1)$ 。

实际上使用的关键字比全域中要少很多，使用杂凑函数将关键字全域映射到一个较小的散列值域中。

两个关键字可能映射到一个散列值中，使用一些方式处理：

- 链接法：同一个槽中使用链表存储卫星数据。效率低。
- 开放寻址法：如果槽中已有数据，按照算法计算下一个位置，形成探查序列。
  - 线性探查： $h(k,i)=(h'(k)+i) \mathrm{mod} m$
  - 二次探查： $h(k,i)=(h'(k)+c_1i+c_2i^2) \mathrm{mod} m$
  - 双重散列： $h(k,i)=(h_1(k)+ih_2(k)) \mathrm{mod} m$

- 完全散列：两级散列，第二级散列的大小不同，根据槽内的元素数量指定大小。$m_i=n_i^2$。空间 $O(n)$，时间 $O(1)$，



## 第12章 二叉搜索树



### 二叉搜索树

每一个节点有元素、卫星数据外，还有三个指针，分别指向父节点、左子节点、右子节点。

左子树上所有元素都小于等于此节点元素，而右子树上所有元素都大于此节点元素。



基本操作

- 插入
- 搜索
- 删除
- 最小值
- 最大值
- 前驱
- 后继



迭代展开比递归快。

### 插入与查询

根据元素大小关系，判断是在左子树还是右子树。



### 遍历

指的是，访问此节点元素是与访问左右子树的关系。

- 前序遍历
- 中序遍历
- 后序遍历



### 前驱与后继

按照遍历顺序，查找。



### 删除

删掉节点元素，如果有子树，需要递归移动。会导致树的高度及结构变化。



### 随机构造二叉搜索树

按照随机次序输入关键字到一棵初始为空的树。

- 指数高度：树的高度作为指数，$Y_n=2^{X_n}$ 
- 秩：树根元素在树中的排序索引。







## 第13章 红黑树



这个地址上讲的比算法导论要好。

[Red-Black Trees | Deletion](https://www.codesdope.com/course/data-structures-red-black-trees-deletion/)



### 红黑树

每个节点上有一个存储位来表示节点的颜色，通过对从根到叶子的简单路径上各个节点的颜色进行约束，保证没有一条路长度不是另一条的两倍。



根节点是黑色的，叶节点也是黑色的。

红色节点的子节点必须是黑色的，反之不然。

从一个节点到其所有叶子节点的黑色节点个数相同。



节点的五个属性：

- 颜色
- 元素
- 左节点指针
- 右节点指针
- 卫星数据指针



黑高：一条简单路径中黑色节点的数量。

使用哨兵节点，即所有为空的指针都指向这个节点。



### 旋转

右旋：把左子节点旋转到父节点的位置上，原左子节点的右节点成为原父节点的左子节点，原父节点成为原左子节点的右节点。

左旋：把右子节点旋转到父节点的位置上，原右子节点的左节点成为原父节点的右子节点，原父节点成为原右子节点的左节点。



### 插入



````c++
RBInsert(T,z)
    y = T.nil
    x = T.root
    // 找到合适的位置
    while x != T.nil
        y = x
        if z.key <x.key
            x = x.left
        else
            x = x.right
    // 插入
    z.p = y
    if y == T.nil
        T.root = z
    elseif z.key < y.key 
        y.left = z
    else 
        y.right = z
    // 设置
    z.left = T.nil
    z.right = T.nil   
    z.color = RED
    
    RBInsertFixup(T,z)
        
RBInsertFixup(T,z)        
    while z.p.color == RED
        if z.p == z.p.p.left
            y=z.p.p.right
            // 如果父节点和父节点的兄弟节点都是红的，就把这两个节点变黑，
            // 父节点的父节点变红，之后改变z为父节点的父节点，迭代。
            // 若此区域代码运行结束后，z为root，那么此树的黑高会增加，由最后算法最后一句实现
            if y.color == RED
                z.p.color = BLACK
                y.color = BLACK
                z.p.p.color = RED
                z = z.p.p
            else
                // 如果是父节点的右子节点，那么需要左旋，将父节点的右子节点变为空，或黑树。
                if z == z.p.right
                    z = z.p
                    LeafRotate(T,z)
                // 之后改变父节点颜色，并右旋，这一步将爷爷节点移动到了其右子树的位置，父节点成为爷爷节点的父节点。
                z.p.color = BLACK
                z.p.p.color = RED
                RightRotate(T,z.p.p)
     	else
         	same as then clause with right and left exchanged
  	T.root.color = BLACK
             
        
````



### 删除





````c++
// 把u换成v。
RBTransplant(T,u,v)
    if u.p == T.nil
        T.root = v
    elseif u == u.p.left
        u.p.left = v
    else 
        u.p.right = v
    v.p = u.p    
        
RBDelete(T,z)
    
    y = z
    yOroginalColor = y.color
    // 左为空，那么就可以直接替换    
    if z.left == T.nil
        x = z.right
        RBTransplant(T,z,z.right)
    // 右为空也一样
    elseif  z.right == T.nil
        x = z.left
        RBTransplant(T,z,z.left)
    // 都不为空，就需要找一个位置能放下两棵子树了。
    // y是z的后继，使y代替z的位置
    else
        // y是右子树中最小的
        y = TreeMinimun(z.right)
        yOroginalColor = y.color
        x = y.right
        // z的右子树根节点最小的就是根节点，
        // 也就是右子树没有左子节点，那么就可以把z的左子树直接放在这了。
        if y.p == z
            x.p = y
        // 如果不是，那么就需要将把y移到z的右子节点位置上
        // 首先将y的右子树移到y的位置上，由于y是最小的，一定没有左子树
        // 之后将y提到z的右子树位置上。
        else 
            RBTransplant(T,y,y.right)
            y.right  = z.right 
            y.right.p = y
        // 使用y替换z
        RBTransplant(T,z,y)    
        y.left = z.left
        y.left.p = y
        y.color = z.color
    // 因为使用y替换了z，所以如果y是黑色的，那么就会破坏结构
    // 而x是替换了y的位置，所以要检测x
    if yOroginalColor == BLACK
       	RBDeleteFixup(T,x)
       
RBDeleteFixup(T,x)   
    // 主要问题是原来y的位置，现在x的位置，原本是一个黑色的
    // 那么移动y之后，就少了一个黑色的
    // 就是要迭代处理这个问题
   	while x != T.root and x.color == BLACK
       	if x == x.p.left
            w = x.p.right
            // 如果兄弟节点是红色的，那么就说明父节点是黑色的，
            // 那么只需要交换兄弟节点与父节点的颜色，之后左旋
            // 但是没有改变少一个黑色节点的问题，而是转化为了其他情况
            // 即父节点为红色节点的情况，此树少了一个黑色，而兄弟树没有少
            if w.color == RED
                w.color = BlACK
                x.p.color = RED
                LeafRotate(T,x.p)
                w = x.p.right
            // 此时兄弟节点一定是黑色的了
            // 如果兄弟节点的子节点都是黑色的，就可以将兄弟节点变红，
            // 这样兄弟节点也少了一个黑色
            // 将矛盾上移，因为没有红色节点可以变为黑色，以恢复红黑树
            if w.left.color == BLACK and w.right.color == BLACK
                w.color = RED
                x = x.p
            else 
                // 如果兄弟节点的右节点为黑色，而左节点为红色
                // 那么就可以换色，右旋，使兄弟节点为黑色，
                // 而兄弟节点的右子节点为红色
                if w.right.color == BLACK
                    w.left.color = BLACK
                    w.color = RED
                    RightRotate(T,w)
                    w = x.p.right
                // 兄弟节点的右子节点为红色
                // 设置颜色后，左旋，这样对于x来说，额外多出了w的黑色，
                // 而w上没有多出黑色，完成修复
                // 本质上是，w的右子节点上的红色变黑，代替w的黑色，
                // x的父节点变成w的黑色，额外补全的缺的一个黑色。
                // w的变成x的父节点的颜色，代替了x的父节点，  
                w.color = x.p.color 
                x.p.color = BLACK
                w.right.color = BLACK
                LeafRotate(T,x.p)
                x = T.root
        else 
           same as then clause with right and left exchanged 
    // 由于x这个子树上缺了一个黑色，如果因为x为红色跳出时，直接变黑即可        
    x.color = BLACK
````













## 第章 



````c++

````



